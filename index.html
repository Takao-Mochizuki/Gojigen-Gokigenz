<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Gozigen Gokigenz - 3D Neon Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --bg-dark: #020308;
      --neon-blue: #00eaff;
      --neon-green: #4aff00;
      --error-red: #ff3366;
      --neon-purple: #bf00ff;
      --neon-gold: #ffd700;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Orbitron', system-ui, -apple-system, sans-serif;
      background: #000;
      color: #e0f7ff;
      overflow: hidden;
    }

    #game-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    .ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    .ui-overlay > * {
      pointer-events: auto;
    }

    .header {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      color: var(--neon-blue);
      text-shadow:
        0 0 10px rgba(0, 234, 255, 0.8),
        0 0 20px rgba(0, 234, 255, 0.6),
        0 0 40px rgba(0, 234, 255, 0.4);
      animation: titleGlow 2s ease-in-out infinite alternate;
    }

    @keyframes titleGlow {
      from { text-shadow: 0 0 10px rgba(0, 234, 255, 0.8), 0 0 20px rgba(0, 234, 255, 0.6); }
      to { text-shadow: 0 0 20px rgba(0, 234, 255, 1), 0 0 40px rgba(0, 234, 255, 0.8), 0 0 60px rgba(0, 234, 255, 0.6); }
    }

    .subtitle {
      font-size: 0.9rem;
      opacity: 0.7;
      letter-spacing: 0.1em;
      margin-top: 8px;
    }

    .status-bar {
      position: absolute;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      border-radius: 999px;
      border: 2px solid rgba(0, 234, 255, 0.5);
      box-shadow:
        0 0 15px rgba(0, 234, 255, 0.3),
        inset 0 0 20px rgba(0, 0, 0, 0.5);
      display: flex;
      gap: 20px;
      font-size: 1rem;
      backdrop-filter: blur(10px);
      background: rgba(0, 5, 15, 0.8);
      min-width: 400px;
      justify-content: center;
    }

    .status-main {
      font-weight: 600;
      letter-spacing: 0.05em;
    }

    .status-main.p1 {
      color: var(--neon-blue);
      text-shadow: 0 0 10px rgba(0, 234, 255, 0.8);
    }

    .status-main.p2 {
      color: var(--neon-green);
      text-shadow: 0 0 10px rgba(74, 255, 0, 0.8);
    }

    .status-message {
      opacity: 0.8;
    }

    .status-message.error {
      color: var(--error-red);
      text-shadow: 0 0 10px rgba(255, 51, 102, 0.8);
      animation: errorShake 0.3s ease;
    }

    @keyframes errorShake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }

    .reserve-panel {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      padding: 20px;
      border-radius: 16px;
      border: 2px solid;
      backdrop-filter: blur(10px);
      background: rgba(0, 5, 15, 0.8);
      min-width: 120px;
    }

    .reserve-panel.p1 {
      left: 20px;
      border-color: rgba(0, 234, 255, 0.5);
      box-shadow:
        0 0 20px rgba(0, 234, 255, 0.3),
        inset 0 0 30px rgba(0, 234, 255, 0.1);
    }

    .reserve-panel.p2 {
      right: 20px;
      border-color: rgba(74, 255, 0, 0.5);
      box-shadow:
        0 0 20px rgba(74, 255, 0, 0.3),
        inset 0 0 30px rgba(74, 255, 0, 0.1);
    }

    .reserve-label {
      text-align: center;
      font-size: 0.85rem;
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .reserve-panel.p1 .reserve-label {
      color: var(--neon-blue);
    }

    .reserve-panel.p2 .reserve-label {
      color: var(--neon-green);
    }

    .reserve-pieces {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }

    .reserve-piece {
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
    }

    .reserve-piece::before {
      content: '';
      position: absolute;
      inset: -4px;
      border-radius: 50%;
      border: 2px solid transparent;
      transition: all 0.3s ease;
    }

    .reserve-piece:hover::before {
      border-color: rgba(255, 255, 255, 0.5);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
    }

    .reserve-piece.selected::before {
      border-color: var(--neon-gold);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
      animation: selectedPulse 1s ease-in-out infinite;
    }

    @keyframes selectedPulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.7; }
    }

    .reserve-piece.p1 {
      background: radial-gradient(circle at 30% 20%, #fff 0%, #00eaff 30%, #004a5a 80%);
      box-shadow:
        0 0 15px rgba(0, 234, 255, 0.7),
        0 0 30px rgba(0, 234, 255, 0.4),
        inset 0 -5px 15px rgba(0, 0, 0, 0.4);
    }

    .reserve-piece.p2 {
      background: radial-gradient(circle at 30% 20%, #fff 0%, #4aff00 30%, #215a00 80%);
      box-shadow:
        0 0 15px rgba(74, 255, 0, 0.7),
        0 0 30px rgba(74, 255, 0, 0.4),
        inset 0 -5px 15px rgba(0, 0, 0, 0.4);
    }

    .reserve-piece.large { width: 60px; height: 60px; }
    .reserve-piece.medium { width: 45px; height: 45px; }
    .reserve-piece.small { width: 30px; height: 30px; }

    .control-row {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
    }

    .btn {
      border-radius: 999px;
      padding: 12px 30px;
      font-size: 1rem;
      font-family: inherit;
      border: 2px solid rgba(0, 234, 255, 0.7);
      background: rgba(0, 0, 0, 0.8);
      color: #e0f7ff;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      cursor: pointer;
      box-shadow:
        0 0 15px rgba(0, 234, 255, 0.5),
        0 0 30px rgba(0, 234, 255, 0.3);
      transition: all 0.3s ease;
    }

    .btn:hover {
      background: rgba(0, 234, 255, 0.2);
      transform: translateY(-3px);
      box-shadow:
        0 0 25px rgba(0, 234, 255, 0.8),
        0 0 50px rgba(0, 234, 255, 0.5);
    }

    .btn:active {
      transform: translateY(0);
    }

    /* モーダル */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 20px;
    }

    .modal.hidden {
      display: none;
    }

    .modal-content {
      background: radial-gradient(ellipse at top, #0a1525 0%, #000000 70%);
      border: 2px solid rgba(0, 234, 255, 0.6);
      border-radius: 20px;
      padding: 40px;
      max-width: 500px;
      width: 100%;
      box-shadow:
        0 0 50px rgba(0, 234, 255, 0.5),
        0 0 100px rgba(0, 234, 255, 0.2),
        inset 0 0 30px rgba(0, 0, 0, 0.9);
    }

    .modal-title {
      font-size: 1.8rem;
      font-weight: 700;
      text-align: center;
      color: var(--neon-blue);
      text-shadow: 0 0 15px rgba(0, 234, 255, 0.8);
      margin-bottom: 30px;
      text-transform: uppercase;
      letter-spacing: 0.15em;
    }

    .mode-buttons, .level-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .mode-btn, .level-btn {
      padding: 18px 28px;
      font-size: 1.1rem;
      font-family: inherit;
      border-radius: 12px;
      border: 2px solid rgba(0, 234, 255, 0.5);
      background: rgba(0, 234, 255, 0.1);
      color: #e0f7ff;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-weight: 500;
    }

    .mode-btn:hover, .level-btn:hover {
      border-color: rgba(0, 234, 255, 0.9);
      background: rgba(0, 234, 255, 0.25);
      box-shadow: 0 0 25px rgba(0, 234, 255, 0.6);
      transform: translateY(-3px) scale(1.02);
    }

    .level-btn.beginner { border-color: rgba(74, 255, 0, 0.5); }
    .level-btn.beginner:hover {
      border-color: rgba(74, 255, 0, 0.9);
      background: rgba(74, 255, 0, 0.2);
      box-shadow: 0 0 25px rgba(74, 255, 0, 0.6);
    }

    .level-btn.intermediate { border-color: rgba(255, 200, 0, 0.5); }
    .level-btn.intermediate:hover {
      border-color: rgba(255, 200, 0, 0.9);
      background: rgba(255, 200, 0, 0.2);
      box-shadow: 0 0 25px rgba(255, 200, 0, 0.6);
    }

    .level-btn.advanced { border-color: rgba(255, 100, 0, 0.5); }
    .level-btn.advanced:hover {
      border-color: rgba(255, 100, 0, 0.9);
      background: rgba(255, 100, 0, 0.2);
      box-shadow: 0 0 25px rgba(255, 100, 0, 0.6);
    }

    .level-btn.pro { border-color: rgba(191, 0, 255, 0.5); }
    .level-btn.pro:hover {
      border-color: rgba(191, 0, 255, 0.9);
      background: rgba(191, 0, 255, 0.2);
      box-shadow: 0 0 25px rgba(191, 0, 255, 0.6);
    }

    .level-description {
      font-size: 0.8rem;
      opacity: 0.6;
      margin-top: 6px;
      font-family: system-ui, sans-serif;
      text-transform: none;
      letter-spacing: 0;
    }

    .mode-btn.how-to-play {
      border-color: rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.05);
    }

    .mode-btn.how-to-play:hover {
      border-color: rgba(255, 255, 255, 0.6);
      background: rgba(255, 255, 255, 0.1);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
    }

    /* 遊び方モーダル */
    .howto-content {
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .howto-body {
      text-align: left;
      font-family: system-ui, sans-serif;
    }

    .howto-section {
      margin-bottom: 24px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(0, 234, 255, 0.2);
    }

    .howto-section:last-child {
      border-bottom: none;
      margin-bottom: 10px;
    }

    .howto-section h3 {
      color: var(--neon-blue);
      font-size: 1.1rem;
      margin-bottom: 12px;
      font-family: 'Orbitron', sans-serif;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .howto-section p {
      line-height: 1.7;
      opacity: 0.9;
    }

    .howto-section ul {
      padding-left: 20px;
      line-height: 1.8;
    }

    .howto-section li {
      margin-bottom: 8px;
      opacity: 0.9;
    }

    .howto-section strong {
      color: var(--neon-green);
    }

    .piece-demo {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 15px 0;
    }

    .demo-piece {
      border-radius: 50%;
      background: radial-gradient(circle at 30% 20%, #fff 0%, #00eaff 30%, #004a5a 80%);
      box-shadow: 0 0 15px rgba(0, 234, 255, 0.7);
    }

    .demo-piece.large { width: 50px; height: 50px; }
    .demo-piece.medium { width: 38px; height: 38px; }
    .demo-piece.small { width: 26px; height: 26px; }

    .tip {
      color: var(--neon-gold);
      font-size: 0.9rem;
    }

    .back-btn {
      margin-top: 20px;
      width: 100%;
    }

    /* 勝利エフェクト */
    .victory-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    .victory-overlay.active {
      opacity: 1;
      pointer-events: auto;
    }

    .victory-text {
      font-size: 4rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      animation: victoryPulse 1s ease-in-out infinite;
    }

    .victory-text.p1 {
      color: var(--neon-blue);
      text-shadow:
        0 0 20px rgba(0, 234, 255, 1),
        0 0 40px rgba(0, 234, 255, 0.8),
        0 0 80px rgba(0, 234, 255, 0.6);
    }

    .victory-text.p2 {
      color: var(--neon-green);
      text-shadow:
        0 0 20px rgba(74, 255, 0, 1),
        0 0 40px rgba(74, 255, 0, 0.8),
        0 0 80px rgba(74, 255, 0, 0.6);
    }

    @keyframes victoryPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .victory-sub {
      font-size: 1.5rem;
      margin-top: 20px;
      opacity: 0.8;
    }

    /* AI思考中インジケーター */
    .thinking-indicator {
      position: absolute;
      top: 160px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      align-items: center;
      gap: 10px;
      padding: 10px 20px;
      background: rgba(0, 5, 15, 0.9);
      border: 1px solid rgba(191, 0, 255, 0.5);
      border-radius: 20px;
      color: var(--neon-purple);
    }

    .thinking-indicator.active {
      display: flex;
    }

    .thinking-dots {
      display: flex;
      gap: 4px;
    }

    .thinking-dots span {
      width: 8px;
      height: 8px;
      background: var(--neon-purple);
      border-radius: 50%;
      animation: thinkingBounce 1.4s ease-in-out infinite;
    }

    .thinking-dots span:nth-child(1) { animation-delay: 0s; }
    .thinking-dots span:nth-child(2) { animation-delay: 0.2s; }
    .thinking-dots span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes thinkingBounce {
      0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
      40% { transform: scale(1); opacity: 1; }
    }

    /* レスポンシブ */
    @media (max-width: 900px) {
      .reserve-panel {
        position: absolute;
        top: auto;
        bottom: 100px;
        transform: none;
        min-width: auto;
        padding: 15px;
      }

      .reserve-panel.p1 { left: 20px; right: auto; }
      .reserve-panel.p2 { right: 20px; left: auto; }

      .reserve-pieces {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
      }

      h1 { font-size: 1.5rem; }
      .status-bar { min-width: auto; padding: 10px 15px; font-size: 0.85rem; }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <canvas id="game-canvas"></canvas>

  <div class="ui-overlay">
    <div class="header">
      <h1>Gozigen Gokigenz</h1>
      <div class="subtitle">3D Neon Edition - Gobble Your Way to Victory</div>
    </div>

    <div class="status-bar" id="status-bar">
      <div class="status-main" id="status-main"></div>
      <div class="status-message" id="status-message"></div>
    </div>

    <div class="thinking-indicator" id="thinking-indicator">
      <span>AI Thinking</span>
      <div class="thinking-dots">
        <span></span><span></span><span></span>
      </div>
    </div>

    <div class="reserve-panel p1" id="reserve-p1">
      <div class="reserve-label">Player 1</div>
      <div class="reserve-pieces" id="reserve-pieces-p1"></div>
    </div>

    <div class="reserve-panel p2" id="reserve-p2">
      <div class="reserve-label">Player 2</div>
      <div class="reserve-pieces" id="reserve-pieces-p2"></div>
    </div>

    <div class="control-row">
      <button class="btn" id="btn-new-game">New Game</button>
    </div>

    <div class="victory-overlay" id="victory-overlay">
      <div class="victory-text" id="victory-text"></div>
      <div class="victory-sub" id="victory-sub"></div>
    </div>
  </div>

  <!-- モーダル -->
  <div class="modal" id="mode-modal">
    <div class="modal-content">
      <div class="modal-title">Select Game Mode</div>
      <div class="mode-buttons">
        <button class="mode-btn" onclick="selectMode('2P')">
          2 Players
          <div class="level-description">対人戦 - 同じ端末で2人で対戦</div>
        </button>
        <button class="mode-btn" onclick="selectMode('CPU')">
          vs Computer
          <div class="level-description">CPU対戦 - コンピューターと対戦</div>
        </button>
        <button class="mode-btn how-to-play" onclick="showHowToPlay()">
          How to Play
          <div class="level-description">遊び方を見る</div>
        </button>
      </div>
    </div>
  </div>

  <!-- 遊び方モーダル -->
  <div class="modal hidden" id="howto-modal">
    <div class="modal-content howto-content">
      <div class="modal-title">How to Play</div>
      <div class="howto-body">
        <div class="howto-section">
          <h3>ゲーム概要</h3>
          <p>「ゴブレットゴブラーズ」を元にした3目並べゲームです。<br>
          自分の駒を縦・横・斜めに3つ並べたら勝ち！</p>
        </div>

        <div class="howto-section">
          <h3>駒について</h3>
          <div class="piece-demo">
            <div class="demo-piece large"></div>
            <div class="demo-piece medium"></div>
            <div class="demo-piece small"></div>
          </div>
          <p>各プレイヤーは大・中・小の駒を2個ずつ（計6個）持っています。</p>
        </div>

        <div class="howto-section">
          <h3>基本ルール</h3>
          <ul>
            <li>自分のターンに、手持ちの駒を盤上に置くか、盤上の自分の駒を移動させます</li>
            <li>空いているマスには、どのサイズの駒でも置けます</li>
            <li><strong>かぶせルール：</strong>より大きい駒は、小さい駒の上にかぶせられます（自分の駒でも相手の駒でもOK！）</li>
            <li>かぶせられた駒は見えなくなりますが、消えたわけではありません</li>
            <li>上の駒が移動すると、下の駒が再び現れます</li>
          </ul>
        </div>

        <div class="howto-section">
          <h3>操作方法</h3>
          <ul>
            <li><strong>駒の選択：</strong>左右の手持ちエリアから駒をクリック、または盤上の自分の駒をクリック</li>
            <li><strong>駒の配置：</strong>駒を選択した状態で、盤上のマスをクリック</li>
            <li><strong>選択解除：</strong>同じ駒をもう一度クリック</li>
          </ul>
        </div>

        <div class="howto-section">
          <h3>勝利条件</h3>
          <p>盤面の最上面に見えている自分の駒を、縦・横・斜めのいずれかで3つ並べたら勝ち！<br>
          <span class="tip">※ヒント：相手の駒をかぶせて勝利を阻止したり、自分の駒を移動させて下から別の駒を出現させる戦略も有効です！</span></p>
        </div>
      </div>
      <button class="btn back-btn" onclick="hideHowToPlay()">戻る</button>
    </div>
  </div>

  <div class="modal hidden" id="level-modal">
    <div class="modal-content">
      <div class="modal-title">Select Difficulty</div>
      <div class="level-buttons">
        <button class="level-btn beginner" onclick="selectLevel('beginner')">
          初心者
          <div class="level-description">ランダムに手を選択 - 初めての方向け</div>
        </button>
        <button class="level-btn intermediate" onclick="selectLevel('intermediate')">
          中級
          <div class="level-description">基本戦略を使用 - 勝ち筋を見つけます</div>
        </button>
        <button class="level-btn advanced" onclick="selectLevel('advanced')">
          上級
          <div class="level-description">ミニマックス法 - 3手先を読みます</div>
        </button>
        <button class="level-btn pro" onclick="selectLevel('pro')">
          プロ
          <div class="level-description">α-β枝刈り搭載 - 5手先を完全読み</div>
        </button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ====== Three.js 3D Setup ======
    let scene, camera, renderer, controls;
    let boardGroup, cellMeshes = [], pieceMeshes = {};
    let particleSystem, glowLights = [];
    let raycaster, mouse;
    let animationMixer;
    let clock = new THREE.Clock();

    // Colors
    const COLORS = {
      p1: 0x00eaff,
      p2: 0x4aff00,
      board: 0x0a1525,
      cell: 0x102030,
      cellHover: 0x1a3050,
      grid: 0x00eaff,
      winning: 0xffd700
    };

    function init3D() {
      const canvas = document.getElementById('game-canvas');

      // Scene
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000510, 0.02);

      // Camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 8, 10);
      camera.lookAt(0, 0, 0);

      // Renderer
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;

      // Raycaster
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // Lights
      setupLights();

      // Board
      createBoard();

      // Particles
      createParticles();

      // Events
      window.addEventListener('resize', onWindowResize);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('click', onClick3D);

      // Animation loop
      animate();
    }

    function setupLights() {
      // Ambient
      const ambient = new THREE.AmbientLight(0x101520, 0.5);
      scene.add(ambient);

      // Main directional light
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(5, 10, 5);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      scene.add(dirLight);

      // Neon blue point light
      const blueLight = new THREE.PointLight(COLORS.p1, 1, 20);
      blueLight.position.set(-5, 5, -5);
      scene.add(blueLight);
      glowLights.push(blueLight);

      // Neon green point light
      const greenLight = new THREE.PointLight(COLORS.p2, 1, 20);
      greenLight.position.set(5, 5, 5);
      scene.add(greenLight);
      glowLights.push(greenLight);

      // Bottom rim light
      const rimLight = new THREE.PointLight(0xbf00ff, 0.5, 15);
      rimLight.position.set(0, -3, 0);
      scene.add(rimLight);
    }

    function createBoard() {
      boardGroup = new THREE.Group();
      scene.add(boardGroup);

      // Board base
      const baseGeom = new THREE.BoxGeometry(8, 0.5, 8);
      const baseMat = new THREE.MeshStandardMaterial({
        color: COLORS.board,
        metalness: 0.8,
        roughness: 0.2,
        transparent: true,
        opacity: 0.9
      });
      const baseMesh = new THREE.Mesh(baseGeom, baseMat);
      baseMesh.position.y = -0.3;
      baseMesh.receiveShadow = true;
      boardGroup.add(baseMesh);

      // Grid lines
      const gridMat = new THREE.LineBasicMaterial({
        color: COLORS.grid,
        transparent: true,
        opacity: 0.6
      });

      for (let i = 0; i <= 3; i++) {
        const pos = -3 + i * 2;

        // Horizontal
        const hPoints = [new THREE.Vector3(-3, 0.01, pos), new THREE.Vector3(3, 0.01, pos)];
        const hGeom = new THREE.BufferGeometry().setFromPoints(hPoints);
        boardGroup.add(new THREE.Line(hGeom, gridMat));

        // Vertical
        const vPoints = [new THREE.Vector3(pos, 0.01, -3), new THREE.Vector3(pos, 0.01, 3)];
        const vGeom = new THREE.BufferGeometry().setFromPoints(vPoints);
        boardGroup.add(new THREE.Line(vGeom, gridMat));
      }

      // Interactive cells
      cellMeshes = [];
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          const cellGeom = new THREE.PlaneGeometry(1.9, 1.9);
          const cellMat = new THREE.MeshStandardMaterial({
            color: COLORS.cell,
            metalness: 0.5,
            roughness: 0.5,
            transparent: true,
            opacity: 0.3
          });
          const cellMesh = new THREE.Mesh(cellGeom, cellMat);
          cellMesh.rotation.x = -Math.PI / 2;
          cellMesh.position.set(-2 + c * 2, 0.02, -2 + r * 2);
          cellMesh.userData = { row: r, col: c };
          boardGroup.add(cellMesh);
          cellMeshes.push(cellMesh);
        }
      }
    }

    function createParticles() {
      const particleCount = 500;
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 30;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 20;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 30;

        const color = Math.random() > 0.5 ?
          new THREE.Color(COLORS.p1) :
          new THREE.Color(COLORS.p2);
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
      }

      const particleGeom = new THREE.BufferGeometry();
      particleGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeom.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const particleMat = new THREE.PointsMaterial({
        size: 0.05,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      });

      particleSystem = new THREE.Points(particleGeom, particleMat);
      scene.add(particleSystem);
    }

    function createPieceMesh(pieceId, owner, size) {
      const sizeMap = { large: 0.7, medium: 0.5, small: 0.35 };
      const radius = sizeMap[size];
      const height = radius * 1.2;

      // Main sphere (slightly flattened)
      const geom = new THREE.SphereGeometry(radius, 32, 24);
      geom.scale(1, 0.7, 1);

      const color = owner === 'P1' ? COLORS.p1 : COLORS.p2;
      const mat = new THREE.MeshStandardMaterial({
        color: color,
        metalness: 0.4,
        roughness: 0.3,
        emissive: color,
        emissiveIntensity: 0.3
      });

      const mesh = new THREE.Mesh(geom, mat);
      mesh.castShadow = true;
      mesh.userData = { pieceId, owner, size };

      // Glow ring
      const ringGeom = new THREE.TorusGeometry(radius * 0.9, 0.03, 16, 32);
      const ringMat = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.6
      });
      const ring = new THREE.Mesh(ringGeom, ringMat);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = -radius * 0.3;
      mesh.add(ring);

      // Inner highlight
      const innerGeom = new THREE.SphereGeometry(radius * 0.3, 16, 16);
      const innerMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.3
      });
      const inner = new THREE.Mesh(innerGeom, innerMat);
      inner.position.set(-radius * 0.2, radius * 0.2, radius * 0.3);
      mesh.add(inner);

      return mesh;
    }

    function placePiece3D(pieceId, row, col, animate = true) {
      const piece = pieces[pieceId];
      let mesh = pieceMeshes[pieceId];

      if (!mesh) {
        mesh = createPieceMesh(pieceId, piece.owner, piece.size);
        pieceMeshes[pieceId] = mesh;
        scene.add(mesh);
      }

      const targetX = -2 + col * 2;
      const targetZ = -2 + row * 2;
      const stack = board[row][col];
      const stackIndex = stack.indexOf(pieceId);
      const targetY = 0.3 + stackIndex * 0.2;

      if (animate) {
        // Animate piece placement
        const startY = 5;
        mesh.position.set(targetX, startY, targetZ);
        mesh.scale.set(0.1, 0.1, 0.1);

        const duration = 500;
        const startTime = Date.now();

        function animateDrop() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic

          mesh.position.y = startY + (targetY - startY) * eased;
          mesh.scale.setScalar(0.1 + 0.9 * eased);

          if (progress < 1) {
            requestAnimationFrame(animateDrop);
          } else {
            // Landing effect
            createLandingParticles(targetX, targetY, targetZ, piece.owner);
          }
        }
        animateDrop();
      } else {
        mesh.position.set(targetX, targetY, targetZ);
      }

      mesh.visible = true;
    }

    function movePiece3D(pieceId, fromRow, fromCol, toRow, toCol) {
      const mesh = pieceMeshes[pieceId];
      if (!mesh) return;

      const piece = pieces[pieceId];
      const targetX = -2 + toCol * 2;
      const targetZ = -2 + toRow * 2;
      const stack = board[toRow][toCol];
      const stackIndex = stack.indexOf(pieceId);
      const targetY = 0.3 + stackIndex * 0.2;

      // Arc animation
      const startPos = mesh.position.clone();
      const duration = 600;
      const startTime = Date.now();
      const arcHeight = 2;

      function animateMove() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = progress < 0.5 ?
          2 * progress * progress :
          1 - Math.pow(-2 * progress + 2, 2) / 2;

        mesh.position.x = startPos.x + (targetX - startPos.x) * eased;
        mesh.position.z = startPos.z + (targetZ - startPos.z) * eased;
        mesh.position.y = startPos.y + (targetY - startPos.y) * eased +
          Math.sin(progress * Math.PI) * arcHeight;

        // Rotation during move
        mesh.rotation.y = progress * Math.PI * 2;

        if (progress < 1) {
          requestAnimationFrame(animateMove);
        } else {
          mesh.rotation.y = 0;
          createLandingParticles(targetX, targetY, targetZ, piece.owner);
        }
      }
      animateMove();
    }

    function createLandingParticles(x, y, z, owner) {
      const color = owner === 'P1' ? COLORS.p1 : COLORS.p2;
      const particleCount = 20;

      for (let i = 0; i < particleCount; i++) {
        const geom = new THREE.SphereGeometry(0.05, 8, 8);
        const mat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 1
        });
        const particle = new THREE.Mesh(geom, mat);
        particle.position.set(x, y, z);

        const angle = (i / particleCount) * Math.PI * 2;
        const velocity = {
          x: Math.cos(angle) * 0.1,
          y: Math.random() * 0.1 + 0.05,
          z: Math.sin(angle) * 0.1
        };

        scene.add(particle);

        const startTime = Date.now();
        function animateParticle() {
          const elapsed = Date.now() - startTime;
          if (elapsed > 500) {
            scene.remove(particle);
            return;
          }

          const progress = elapsed / 500;
          particle.position.x += velocity.x;
          particle.position.y += velocity.y - progress * 0.02;
          particle.position.z += velocity.z;
          particle.material.opacity = 1 - progress;
          particle.scale.setScalar(1 - progress * 0.5);

          requestAnimationFrame(animateParticle);
        }
        animateParticle();
      }
    }

    function highlightWinningLine3D(line, owner) {
      const color = owner === 'P1' ? COLORS.p1 : COLORS.p2;

      // Create glowing line
      const points = line.map(([r, c]) => new THREE.Vector3(-2 + c * 2, 0.5, -2 + r * 2));
      const lineGeom = new THREE.BufferGeometry().setFromPoints(points);
      const lineMat = new THREE.LineBasicMaterial({
        color: COLORS.winning,
        linewidth: 3,
        transparent: true,
        opacity: 0.8
      });
      const winLine = new THREE.Line(lineGeom, lineMat);
      scene.add(winLine);

      // Pulse cells
      line.forEach(([r, c]) => {
        const cellMesh = cellMeshes.find(m => m.userData.row === r && m.userData.col === c);
        if (cellMesh) {
          cellMesh.material.color.setHex(COLORS.winning);
          cellMesh.material.emissive = new THREE.Color(COLORS.winning);
          cellMesh.material.emissiveIntensity = 0.5;
          cellMesh.material.opacity = 0.6;
        }
      });

      // Animate winning pieces
      line.forEach(([r, c]) => {
        const stack = board[r][c];
        if (stack.length > 0) {
          const topId = stack[stack.length - 1];
          const mesh = pieceMeshes[topId];
          if (mesh) {
            const startTime = Date.now();
            function pulse() {
              if (gameOver) {
                const elapsed = Date.now() - startTime;
                const scale = 1 + Math.sin(elapsed / 200) * 0.1;
                mesh.scale.setScalar(scale);
                mesh.material.emissiveIntensity = 0.3 + Math.sin(elapsed / 150) * 0.2;
                requestAnimationFrame(pulse);
              }
            }
            pulse();
          }
        }
      });
    }

    function updatePieceVisibility() {
      // Hide pieces that are covered
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          const stack = board[r][c];
          stack.forEach((pieceId, index) => {
            const mesh = pieceMeshes[pieceId];
            if (mesh) {
              // Only show top piece fully, others partially
              if (index === stack.length - 1) {
                mesh.material.opacity = 1;
              } else {
                mesh.material.opacity = 0.3;
              }
            }
          });
        }
      }
    }

    function resetBoard3D() {
      // Remove all piece meshes
      Object.values(pieceMeshes).forEach(mesh => {
        scene.remove(mesh);
      });
      pieceMeshes = {};

      // Reset cell colors
      cellMeshes.forEach(cell => {
        cell.material.color.setHex(COLORS.cell);
        cell.material.emissive = new THREE.Color(0x000000);
        cell.material.emissiveIntensity = 0;
        cell.material.opacity = 0.3;
      });

      // Remove winning lines
      scene.children = scene.children.filter(child => !(child instanceof THREE.Line && child.material.color.getHex() === COLORS.winning));
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    let hoveredCell = null;
    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(cellMeshes);

      // Reset previous hover
      if (hoveredCell && hoveredCell !== intersects[0]?.object) {
        if (!winningLine || !winningLine.some(([r,c]) =>
            hoveredCell.userData.row === r && hoveredCell.userData.col === c)) {
          hoveredCell.material.color.setHex(COLORS.cell);
          hoveredCell.material.opacity = 0.3;
        }
      }

      if (intersects.length > 0 && !gameOver && selectedPieceId) {
        hoveredCell = intersects[0].object;
        hoveredCell.material.color.setHex(COLORS.cellHover);
        hoveredCell.material.opacity = 0.5;
        document.body.style.cursor = 'pointer';
      } else {
        hoveredCell = null;
        document.body.style.cursor = 'default';
      }
    }

    function onClick3D(event) {
      if (gameOver || isAIThinking) return;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(cellMeshes);

      if (intersects.length > 0 && selectedPieceId) {
        const cell = intersects[0].object;
        const { row, col } = cell.userData;
        handleCellClick(row, col);
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const time = clock.getElapsedTime();

      // Rotate particles slowly
      if (particleSystem) {
        particleSystem.rotation.y += delta * 0.05;
      }

      // Subtle camera movement
      camera.position.x = Math.sin(time * 0.2) * 0.5;
      camera.position.z = 10 + Math.cos(time * 0.15) * 0.3;
      camera.lookAt(0, 0, 0);

      // Pulse glow lights
      glowLights.forEach((light, i) => {
        light.intensity = 0.8 + Math.sin(time * 2 + i) * 0.3;
      });

      // Animate board tilt based on current player
      if (!gameOver) {
        const targetRotation = currentPlayer === 'P1' ? -0.05 : 0.05;
        boardGroup.rotation.y += (targetRotation - boardGroup.rotation.y) * 0.02;
      }

      renderer.render(scene, camera);
    }

    // ====== ゲーム状態 ======
    const BOARD_SIZE = 3;
    const SIZE_RANK = { small: 1, medium: 2, large: 3 };

    let board = [];
    let pieces = {};
    let currentPlayer = 'P1';
    let selectedPieceId = null;
    let winner = null;
    let winningLine = null;
    let gameOver = false;
    let gameMode = null;
    let aiLevel = null;
    let isAIThinking = false;

    const statusMainEl = document.getElementById('status-main');
    const statusMsgEl = document.getElementById('status-message');
    const statusBarEl = document.getElementById('status-bar');
    const btnNewGame = document.getElementById('btn-new-game');
    const victoryOverlay = document.getElementById('victory-overlay');
    const victoryText = document.getElementById('victory-text');
    const victorySub = document.getElementById('victory-sub');
    const thinkingIndicator = document.getElementById('thinking-indicator');

    // ====== 初期化 ======
    function initBoardArray() {
      board = [];
      for (let r = 0; r < BOARD_SIZE; r++) {
        const row = [];
        for (let c = 0; c < BOARD_SIZE; c++) {
          row.push([]);
        }
        board.push(row);
      }
    }

    function initPieces() {
      pieces = {};
      const config = [
        { size: 'large', count: 2 },
        { size: 'medium', count: 2 },
        { size: 'small', count: 2 }
      ];

      ['P1', 'P2'].forEach(owner => {
        config.forEach(cfg => {
          for (let i = 0; i < cfg.count; i++) {
            const id = `${owner}-${cfg.size}-${i}`;
            pieces[id] = {
              id,
              owner,
              size: cfg.size,
              location: 'reserve'
            };
          }
        });
      });
    }

    function newGame() {
      initBoardArray();
      initPieces();
      resetBoard3D();
      currentPlayer = 'P1';
      selectedPieceId = null;
      winner = null;
      winningLine = null;
      gameOver = false;
      victoryOverlay.classList.remove('active');
      renderReserves();
      updateStatusBar();
      setStatusMessage('駒を選んでボード上に配置してください');
    }

    // ====== UI描画 ======
    function renderReserves() {
      const p1Container = document.getElementById('reserve-pieces-p1');
      const p2Container = document.getElementById('reserve-pieces-p2');
      p1Container.innerHTML = '';
      p2Container.innerHTML = '';

      // Sort by size (large first)
      const sizeOrder = { large: 0, medium: 1, small: 2 };

      Object.values(pieces)
        .filter(p => p.location === 'reserve')
        .sort((a, b) => sizeOrder[a.size] - sizeOrder[b.size])
        .forEach(piece => {
          const el = document.createElement('div');
          el.className = `reserve-piece ${piece.owner.toLowerCase()} ${piece.size}`;
          el.dataset.pieceId = piece.id;
          if (piece.id === selectedPieceId) {
            el.classList.add('selected');
          }
          el.addEventListener('click', (e) => onReservePieceClick(e, piece.id));

          if (piece.owner === 'P1') {
            p1Container.appendChild(el);
          } else {
            p2Container.appendChild(el);
          }
        });
    }

    function updateStatusBar() {
      if (winner) {
        const playerName = winner === 'P1' ? 'Player 1' : (gameMode === 'CPU' ? 'AI' : 'Player 2');
        statusMainEl.textContent = `${playerName} Wins!`;
        statusMainEl.className = `status-main ${winner.toLowerCase()}`;
      } else {
        const playerName = currentPlayer === 'P1' ? 'Player 1' : (gameMode === 'CPU' ? 'AI' : 'Player 2');
        statusMainEl.textContent = `${playerName} のターン`;
        statusMainEl.className = `status-main ${currentPlayer.toLowerCase()}`;
      }
    }

    function setStatusMessage(msg, isError = false) {
      statusMsgEl.textContent = msg || '';
      statusMsgEl.classList.toggle('error', !!isError);
    }

    function flashError(msg) {
      setStatusMessage(msg, true);
      setTimeout(() => {
        if (!winner) setStatusMessage('');
      }, 1500);
    }

    function showVictory(winnerPlayer) {
      const playerName = winnerPlayer === 'P1' ? 'Player 1' : (gameMode === 'CPU' ? 'AI' : 'Player 2');
      victoryText.textContent = `${playerName} Wins!`;
      victoryText.className = `victory-text ${winnerPlayer.toLowerCase()}`;
      victorySub.textContent = winnerPlayer === 'P1' ? '光の勝利!' : 'グリーンの支配!';
      victoryOverlay.classList.add('active');
    }

    // ====== イベントハンドラ ======
    function onReservePieceClick(e, pieceId) {
      if (gameOver || isAIThinking) return;
      e.stopPropagation();

      const piece = pieces[pieceId];
      if (piece.owner !== currentPlayer) {
        flashError('相手の駒は選択できません');
        return;
      }

      if (selectedPieceId === pieceId) {
        selectedPieceId = null;
        setStatusMessage('');
      } else {
        selectedPieceId = pieceId;
        setStatusMessage('ボード上のセルをクリックして配置');
      }

      renderReserves();
    }

    function handleCellClick(row, col) {
      if (gameOver || isAIThinking) return;

      if (!selectedPieceId) {
        // Try to select piece from board
        const stack = board[row][col];
        if (stack.length > 0) {
          const topId = stack[stack.length - 1];
          const topPiece = pieces[topId];
          if (topPiece.owner === currentPlayer) {
            selectedPieceId = topId;
            setStatusMessage('移動先のセルを選択');
            renderReserves();
            return;
          } else {
            flashError('相手の駒は選択できません');
            return;
          }
        }
        flashError('まず駒を選択してください');
        return;
      }

      const piece = pieces[selectedPieceId];
      if (piece.owner !== currentPlayer) {
        flashError('相手の駒は動かせません');
        selectedPieceId = null;
        renderReserves();
        return;
      }

      // Check if can place
      const destStack = board[row][col];
      const topId = destStack.length ? destStack[destStack.length - 1] : null;

      if (topId) {
        const topPiece = pieces[topId];
        if (SIZE_RANK[piece.size] <= SIZE_RANK[topPiece.size]) {
          flashError('同サイズ以上の駒の上には置けません');
          return;
        }
      }

      // Execute move
      const fromLocation = piece.location;

      // Remove from old position
      if (fromLocation !== 'reserve') {
        const { row: fromRow, col: fromCol } = fromLocation;
        const fromStack = board[fromRow][fromCol];
        const index = fromStack.indexOf(piece.id);
        if (index !== -1) fromStack.splice(index, 1);

        // Animate move
        movePiece3D(piece.id, fromRow, fromCol, row, col);
      } else {
        // Place from reserve
        placePiece3D(piece.id, row, col, true);
      }

      // Add to new position
      destStack.push(piece.id);
      piece.location = { row, col };
      selectedPieceId = null;

      updatePieceVisibility();
      renderReserves();

      // Check win
      const winOwner = checkWin();
      if (winOwner) {
        winner = winOwner;
        gameOver = true;
        highlightWinningLine3D(winningLine, winOwner);
        setTimeout(() => showVictory(winOwner), 800);
      } else {
        currentPlayer = currentPlayer === 'P1' ? 'P2' : 'P1';
        setStatusMessage('');
      }

      updateStatusBar();

      // AI turn
      if (!gameOver && gameMode === 'CPU' && currentPlayer === 'P2') {
        setTimeout(() => aiMove(), 600);
      }
    }

    // ====== 勝敗判定 ======
    function checkWin() {
      const lines = [
        [[0,0],[0,1],[0,2]], [[1,0],[1,1],[1,2]], [[2,0],[2,1],[2,2]],
        [[0,0],[1,0],[2,0]], [[0,1],[1,1],[2,1]], [[0,2],[1,2],[2,2]],
        [[0,0],[1,1],[2,2]], [[0,2],[1,1],[2,0]]
      ];

      winningLine = null;

      for (const line of lines) {
        let owner = null;
        let valid = true;

        for (const [r, c] of line) {
          const stack = board[r][c];
          if (!stack.length) {
            valid = false;
            break;
          }
          const topPiece = pieces[stack[stack.length - 1]];
          if (!owner) {
            owner = topPiece.owner;
          } else if (owner !== topPiece.owner) {
            valid = false;
            break;
          }
        }

        if (valid && owner) {
          winningLine = line;
          return owner;
        }
      }

      return null;
    }

    // ====== モード選択 ======
    function selectMode(mode) {
      gameMode = mode;
      document.getElementById('mode-modal').classList.add('hidden');

      if (mode === 'CPU') {
        document.getElementById('level-modal').classList.remove('hidden');
      } else {
        startGame();
      }
    }

    function selectLevel(level) {
      aiLevel = level;
      document.getElementById('level-modal').classList.add('hidden');
      startGame();
    }

    function startGame() {
      newGame();
      if (gameMode === 'CPU' && currentPlayer === 'P2') {
        setTimeout(() => aiMove(), 800);
      }
    }

    function showModeSelection() {
      document.getElementById('mode-modal').classList.remove('hidden');
      document.getElementById('level-modal').classList.add('hidden');
      document.getElementById('howto-modal').classList.add('hidden');
    }

    function showHowToPlay() {
      document.getElementById('mode-modal').classList.add('hidden');
      document.getElementById('howto-modal').classList.remove('hidden');
    }

    function hideHowToPlay() {
      document.getElementById('howto-modal').classList.add('hidden');
      document.getElementById('mode-modal').classList.remove('hidden');
    }

    // ====== AI ロジック（強化版）======
    function aiMove() {
      if (gameOver || isAIThinking || gameMode !== 'CPU' || currentPlayer !== 'P2') return;

      isAIThinking = true;
      thinkingIndicator.classList.add('active');
      setStatusMessage('AI思考中...');

      const thinkTime = aiLevel === 'pro' ? 1200 : (aiLevel === 'advanced' ? 800 : 500);

      setTimeout(() => {
        let move = null;

        switch (aiLevel) {
          case 'beginner':
            move = aiBeginnerMove();
            break;
          case 'intermediate':
            move = aiIntermediateMove();
            break;
          case 'advanced':
            move = aiAdvancedMove();
            break;
          case 'pro':
            move = aiProMove();
            break;
        }

        if (move) {
          executeAIMove(move);
        }

        isAIThinking = false;
        thinkingIndicator.classList.remove('active');
      }, thinkTime);
    }

    // 合法手を全取得
    function getAllLegalMoves(player) {
      const moves = [];

      Object.values(pieces).forEach(piece => {
        if (piece.owner === player) {
          if (piece.location === 'reserve') {
            // Reserve pieces
            for (let r = 0; r < 3; r++) {
              for (let c = 0; c < 3; c++) {
                if (canPlacePiece(piece.id, r, c)) {
                  moves.push({ pieceId: piece.id, row: r, col: c });
                }
              }
            }
          } else {
            // Board pieces (top only)
            const { row: fromRow, col: fromCol } = piece.location;
            const stack = board[fromRow][fromCol];
            if (stack[stack.length - 1] === piece.id) {
              for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                  if (r !== fromRow || c !== fromCol) {
                    if (canPlacePiece(piece.id, r, c)) {
                      moves.push({ pieceId: piece.id, row: r, col: c });
                    }
                  }
                }
              }
            }
          }
        }
      });

      return moves;
    }

    function canPlacePiece(pieceId, row, col) {
      const piece = pieces[pieceId];
      const destStack = board[row][col];
      const topId = destStack.length ? destStack[destStack.length - 1] : null;

      if (!topId) return true;
      return SIZE_RANK[piece.size] > SIZE_RANK[pieces[topId].size];
    }

    // 初心者AI
    function aiBeginnerMove() {
      const moves = getAllLegalMoves('P2');
      return moves[Math.floor(Math.random() * moves.length)];
    }

    // 中級AI
    function aiIntermediateMove() {
      // Win if possible
      const winMove = findWinningMove('P2');
      if (winMove) return winMove;

      // Block opponent's win
      const blockMove = findWinningMove('P1');
      if (blockMove) return blockMove;

      // Prioritize center
      const centerMove = findCenterMove('P2');
      if (centerMove) return centerMove;

      return aiBeginnerMove();
    }

    // 上級AI（ミニマックス法）
    function aiAdvancedMove() {
      const moves = getAllLegalMoves('P2');
      let bestMove = null;
      let bestScore = -Infinity;

      for (const move of moves) {
        const undoInfo = applyMove(move);
        const score = minimax(2, false, -Infinity, Infinity);
        undoMove(undoInfo);

        if (score > bestScore) {
          bestScore = score;
          bestMove = move;
        }
      }

      return bestMove || aiIntermediateMove();
    }

    // プロAI（深いミニマックス + 高度な評価）
    function aiProMove() {
      const moves = getAllLegalMoves('P2');
      let bestMove = null;
      let bestScore = -Infinity;

      // Sort moves by preliminary evaluation for better pruning
      const scoredMoves = moves.map(move => {
        const undoInfo = applyMove(move);
        const score = evaluatePosition('P2');
        undoMove(undoInfo);
        return { move, score };
      });
      scoredMoves.sort((a, b) => b.score - a.score);

      for (const { move } of scoredMoves) {
        const undoInfo = applyMove(move);
        const score = minimax(4, false, -Infinity, Infinity);
        undoMove(undoInfo);

        if (score > bestScore) {
          bestScore = score;
          bestMove = move;
        }
      }

      return bestMove || aiAdvancedMove();
    }

    // ミニマックス + α-β枝刈り
    function minimax(depth, isMaximizing, alpha, beta) {
      const winOwner = checkWin();
      if (winOwner === 'P2') return 10000 + depth;
      if (winOwner === 'P1') return -10000 - depth;
      if (depth === 0) return evaluatePosition('P2');

      const player = isMaximizing ? 'P2' : 'P1';
      const moves = getAllLegalMoves(player);

      if (moves.length === 0) return evaluatePosition('P2');

      if (isMaximizing) {
        let maxScore = -Infinity;
        for (const move of moves) {
          const undoInfo = applyMove(move);
          const score = minimax(depth - 1, false, alpha, beta);
          undoMove(undoInfo);
          maxScore = Math.max(maxScore, score);
          alpha = Math.max(alpha, score);
          if (beta <= alpha) break;
        }
        return maxScore;
      } else {
        let minScore = Infinity;
        for (const move of moves) {
          const undoInfo = applyMove(move);
          const score = minimax(depth - 1, true, alpha, beta);
          undoMove(undoInfo);
          minScore = Math.min(minScore, score);
          beta = Math.min(beta, score);
          if (beta <= alpha) break;
        }
        return minScore;
      }
    }

    // 高度な局面評価
    function evaluatePosition(player) {
      let score = 0;
      const opponent = player === 'P1' ? 'P2' : 'P1';

      const lines = [
        [[0,0],[0,1],[0,2]], [[1,0],[1,1],[1,2]], [[2,0],[2,1],[2,2]],
        [[0,0],[1,0],[2,0]], [[0,1],[1,1],[2,1]], [[0,2],[1,2],[2,2]],
        [[0,0],[1,1],[2,2]], [[0,2],[1,1],[2,0]]
      ];

      for (const line of lines) {
        const lineInfo = analyzeLineAdvanced(line, player, opponent);

        // Win immediately
        if (lineInfo.playerCount === 3) return 10000;
        if (lineInfo.opponentCount === 3) return -10000;

        // Two in a row with empty
        if (lineInfo.playerCount === 2 && lineInfo.emptyCount === 1) score += 100;
        if (lineInfo.opponentCount === 2 && lineInfo.emptyCount === 1) score -= 150;

        // Potential to gobble
        if (lineInfo.playerCount === 2 && lineInfo.canGobble) score += 200;
        if (lineInfo.opponentCount === 2 && lineInfo.opponentCanGobble) score -= 250;

        // One piece in line
        if (lineInfo.playerCount === 1 && lineInfo.emptyCount === 2) score += 10;
        if (lineInfo.opponentCount === 1 && lineInfo.emptyCount === 2) score -= 10;

        // Control with large pieces
        score += lineInfo.playerLargeCount * 15;
        score -= lineInfo.opponentLargeCount * 15;
      }

      // Center control bonus
      const centerStack = board[1][1];
      if (centerStack.length > 0) {
        const centerOwner = pieces[centerStack[centerStack.length - 1]].owner;
        if (centerOwner === player) score += 50;
        else score -= 50;
      }

      // Corner control
      const corners = [[0,0], [0,2], [2,0], [2,2]];
      corners.forEach(([r, c]) => {
        const stack = board[r][c];
        if (stack.length > 0) {
          const owner = pieces[stack[stack.length - 1]].owner;
          if (owner === player) score += 20;
          else score -= 20;
        }
      });

      // Reserve pieces bonus (having options is good)
      Object.values(pieces).forEach(piece => {
        if (piece.location === 'reserve') {
          if (piece.owner === player) score += SIZE_RANK[piece.size] * 5;
          else score -= SIZE_RANK[piece.size] * 5;
        }
      });

      // Fork potential (multiple winning threats)
      const playerWinThreats = countWinThreats(player);
      const opponentWinThreats = countWinThreats(opponent);
      if (playerWinThreats >= 2) score += 300;
      if (opponentWinThreats >= 2) score -= 400;

      return score;
    }

    function analyzeLineAdvanced(line, player, opponent) {
      let playerCount = 0;
      let opponentCount = 0;
      let emptyCount = 0;
      let playerLargeCount = 0;
      let opponentLargeCount = 0;
      let canGobble = false;
      let opponentCanGobble = false;

      for (const [r, c] of line) {
        const stack = board[r][c];
        if (stack.length === 0) {
          emptyCount++;
        } else {
          const topPiece = pieces[stack[stack.length - 1]];
          if (topPiece.owner === player) {
            playerCount++;
            if (topPiece.size === 'large') playerLargeCount++;
          } else {
            opponentCount++;
            if (topPiece.size === 'large') opponentLargeCount++;
          }

          // Check gobble potential
          if (topPiece.owner === opponent && topPiece.size !== 'large') {
            // Can player gobble this?
            const canGobbleThis = Object.values(pieces).some(p =>
              p.owner === player &&
              SIZE_RANK[p.size] > SIZE_RANK[topPiece.size] &&
              (p.location === 'reserve' ||
                (p.location !== 'reserve' && board[p.location.row][p.location.col][board[p.location.row][p.location.col].length - 1] === p.id))
            );
            if (canGobbleThis) canGobble = true;
          }
          if (topPiece.owner === player && topPiece.size !== 'large') {
            const canOpponentGobbleThis = Object.values(pieces).some(p =>
              p.owner === opponent &&
              SIZE_RANK[p.size] > SIZE_RANK[topPiece.size] &&
              (p.location === 'reserve' ||
                (p.location !== 'reserve' && board[p.location.row][p.location.col][board[p.location.row][p.location.col].length - 1] === p.id))
            );
            if (canOpponentGobbleThis) opponentCanGobble = true;
          }
        }
      }

      return { playerCount, opponentCount, emptyCount, playerLargeCount, opponentLargeCount, canGobble, opponentCanGobble };
    }

    function countWinThreats(player) {
      let threats = 0;
      const lines = [
        [[0,0],[0,1],[0,2]], [[1,0],[1,1],[1,2]], [[2,0],[2,1],[2,2]],
        [[0,0],[1,0],[2,0]], [[0,1],[1,1],[2,1]], [[0,2],[1,2],[2,2]],
        [[0,0],[1,1],[2,2]], [[0,2],[1,1],[2,0]]
      ];

      for (const line of lines) {
        let playerCount = 0;
        let canComplete = true;

        for (const [r, c] of line) {
          const stack = board[r][c];
          if (stack.length === 0) continue;

          const topPiece = pieces[stack[stack.length - 1]];
          if (topPiece.owner === player) {
            playerCount++;
          } else {
            // Can we gobble?
            const canGobble = Object.values(pieces).some(p =>
              p.owner === player &&
              SIZE_RANK[p.size] > SIZE_RANK[topPiece.size] &&
              (p.location === 'reserve' ||
                (p.location !== 'reserve' && board[p.location.row][p.location.col][board[p.location.row][p.location.col].length - 1] === p.id))
            );
            if (!canGobble) canComplete = false;
          }
        }

        if (playerCount === 2 && canComplete) threats++;
      }

      return threats;
    }

    function findWinningMove(player) {
      const moves = getAllLegalMoves(player);
      for (const move of moves) {
        const undoInfo = applyMove(move);
        const winOwner = checkWin();
        undoMove(undoInfo);
        if (winOwner === player) return move;
      }
      return null;
    }

    function findCenterMove(player) {
      const moves = getAllLegalMoves(player);
      return moves.find(m => m.row === 1 && m.col === 1) || null;
    }

    // Move execution for AI evaluation
    function applyMove(move) {
      const { pieceId, row, col } = move;
      const piece = pieces[pieceId];
      const oldLocation = piece.location;
      let oldStack = null;

      if (oldLocation !== 'reserve') {
        const { row: fromRow, col: fromCol } = oldLocation;
        oldStack = [...board[fromRow][fromCol]];
        const fromStack = board[fromRow][fromCol];
        const index = fromStack.indexOf(pieceId);
        if (index !== -1) fromStack.splice(index, 1);
      }

      board[row][col].push(pieceId);
      piece.location = { row, col };

      return { pieceId, oldLocation, oldStack, newRow: row, newCol: col };
    }

    function undoMove(undoInfo) {
      const { pieceId, oldLocation, oldStack, newRow, newCol } = undoInfo;
      const piece = pieces[pieceId];

      const newStack = board[newRow][newCol];
      const index = newStack.indexOf(pieceId);
      if (index !== -1) newStack.splice(index, 1);

      if (oldLocation !== 'reserve') {
        board[oldLocation.row][oldLocation.col] = [...oldStack];
      }
      piece.location = oldLocation;
    }

    function executeAIMove(move) {
      const { pieceId, row, col } = move;
      const piece = pieces[pieceId];
      const fromLocation = piece.location;

      // Remove from old position
      if (fromLocation !== 'reserve') {
        const { row: fromRow, col: fromCol } = fromLocation;
        const fromStack = board[fromRow][fromCol];
        const index = fromStack.indexOf(pieceId);
        if (index !== -1) fromStack.splice(index, 1);
        movePiece3D(pieceId, fromRow, fromCol, row, col);
      } else {
        placePiece3D(pieceId, row, col, true);
      }

      // Add to new position
      board[row][col].push(pieceId);
      piece.location = { row, col };

      updatePieceVisibility();
      renderReserves();

      // Check win
      const winOwner = checkWin();
      if (winOwner) {
        winner = winOwner;
        gameOver = true;
        highlightWinningLine3D(winningLine, winOwner);
        setTimeout(() => showVictory(winOwner), 800);
      } else {
        currentPlayer = 'P1';
        setStatusMessage('');
      }

      updateStatusBar();
    }

    // ====== イベント登録 ======
    btnNewGame.addEventListener('click', showModeSelection);

    // 3Dクリックで盤上の駒も選択可能に
    document.getElementById('game-canvas').addEventListener('click', (event) => {
      if (gameOver || isAIThinking) return;

      raycaster.setFromCamera(mouse, camera);

      // Check piece meshes first
      const pieceMeshArray = Object.values(pieceMeshes).filter(m => m.visible);
      const pieceIntersects = raycaster.intersectObjects(pieceMeshArray);

      if (pieceIntersects.length > 0 && !selectedPieceId) {
        const mesh = pieceIntersects[0].object;
        // Find the parent mesh with userData
        let target = mesh;
        while (target && !target.userData.pieceId) {
          target = target.parent;
        }
        if (target && target.userData.pieceId) {
          const piece = pieces[target.userData.pieceId];
          if (piece.owner === currentPlayer && piece.location !== 'reserve') {
            const { row, col } = piece.location;
            const stack = board[row][col];
            if (stack[stack.length - 1] === piece.id) {
              selectedPieceId = piece.id;
              setStatusMessage('移動先のセルを選択');
              renderReserves();
              return;
            }
          }
        }
      }
    });

    // ====== 初期化 ======
    init3D();
    showModeSelection();
  </script>
</body>
</html>
