<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Gozigen Gokigenz - 3D Neon Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --bg-dark: #020308;
      --neon-blue: #00eaff;
      --neon-green: #4aff00;
      --error-red: #ff3366;
      --neon-purple: #bf00ff;
      --neon-gold: #ffd700;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Orbitron', system-ui, -apple-system, sans-serif;
      background: #000;
      color: #e0f7ff;
      overflow: hidden;
    }

    #game-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    .ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    .ui-overlay > * {
      pointer-events: auto;
    }

    .header {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      color: var(--neon-blue);
      text-shadow:
        0 0 10px rgba(0, 234, 255, 0.8),
        0 0 20px rgba(0, 234, 255, 0.6),
        0 0 40px rgba(0, 234, 255, 0.4);
      animation: titleGlow 2s ease-in-out infinite alternate;
    }

    @keyframes titleGlow {
      from { text-shadow: 0 0 10px rgba(0, 234, 255, 0.8), 0 0 20px rgba(0, 234, 255, 0.6); }
      to { text-shadow: 0 0 20px rgba(0, 234, 255, 1), 0 0 40px rgba(0, 234, 255, 0.8), 0 0 60px rgba(0, 234, 255, 0.6); }
    }

    .subtitle {
      font-size: 0.9rem;
      opacity: 0.7;
      letter-spacing: 0.1em;
      margin-top: 8px;
    }

    .status-bar {
      position: absolute;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      border-radius: 999px;
      border: 2px solid rgba(0, 234, 255, 0.5);
      box-shadow:
        0 0 15px rgba(0, 234, 255, 0.3),
        inset 0 0 20px rgba(0, 0, 0, 0.5);
      display: flex;
      gap: 20px;
      font-size: 1rem;
      backdrop-filter: blur(10px);
      background: rgba(0, 5, 15, 0.8);
      min-width: 400px;
      justify-content: center;
    }

    .status-main {
      font-weight: 600;
      letter-spacing: 0.05em;
    }

    .status-main.p1 {
      color: var(--neon-blue);
      text-shadow: 0 0 10px rgba(0, 234, 255, 0.8);
    }

    .status-main.p2 {
      color: var(--neon-green);
      text-shadow: 0 0 10px rgba(74, 255, 0, 0.8);
    }

    .status-message {
      opacity: 0.8;
    }

    .status-message.error {
      color: var(--error-red);
      text-shadow: 0 0 10px rgba(255, 51, 102, 0.8);
      animation: errorShake 0.3s ease;
    }

    @keyframes errorShake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }

    .reserve-panel {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      padding: 20px;
      border-radius: 16px;
      border: 2px solid;
      backdrop-filter: blur(10px);
      background: rgba(0, 5, 15, 0.8);
      min-width: 120px;
    }

    .reserve-panel.p1 {
      left: 20px;
      border-color: rgba(0, 234, 255, 0.5);
      box-shadow:
        0 0 20px rgba(0, 234, 255, 0.3),
        inset 0 0 30px rgba(0, 234, 255, 0.1);
    }

    .reserve-panel.p2 {
      right: 20px;
      border-color: rgba(74, 255, 0, 0.5);
      box-shadow:
        0 0 20px rgba(74, 255, 0, 0.3),
        inset 0 0 30px rgba(74, 255, 0, 0.1);
    }

    .reserve-label {
      text-align: center;
      font-size: 0.85rem;
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .reserve-panel.p1 .reserve-label {
      color: var(--neon-blue);
    }

    .reserve-panel.p2 .reserve-label {
      color: var(--neon-green);
    }

    .reserve-pieces {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }

    .reserve-piece {
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
    }

    .reserve-piece::before {
      content: '';
      position: absolute;
      inset: -4px;
      border-radius: 50%;
      border: 2px solid transparent;
      transition: all 0.3s ease;
    }

    .reserve-piece:hover::before {
      border-color: rgba(255, 255, 255, 0.5);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
    }

    .reserve-piece.selected::before {
      border-color: var(--neon-gold);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
      animation: selectedPulse 1s ease-in-out infinite;
    }

    @keyframes selectedPulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.7; }
    }

    .reserve-piece.p1 {
      background: radial-gradient(circle at 30% 20%, #fff 0%, #00eaff 30%, #004a5a 80%);
      box-shadow:
        0 0 15px rgba(0, 234, 255, 0.7),
        0 0 30px rgba(0, 234, 255, 0.4),
        inset 0 -5px 15px rgba(0, 0, 0, 0.4);
    }

    .reserve-piece.p2 {
      background: radial-gradient(circle at 30% 20%, #fff 0%, #4aff00 30%, #215a00 80%);
      box-shadow:
        0 0 15px rgba(74, 255, 0, 0.7),
        0 0 30px rgba(74, 255, 0, 0.4),
        inset 0 -5px 15px rgba(0, 0, 0, 0.4);
    }

    .reserve-piece.large { width: 60px; height: 60px; }
    .reserve-piece.medium { width: 45px; height: 45px; }
    .reserve-piece.small { width: 30px; height: 30px; }

    .control-row {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
    }

    .btn {
      border-radius: 999px;
      padding: 12px 30px;
      font-size: 1rem;
      font-family: inherit;
      border: 2px solid rgba(0, 234, 255, 0.7);
      background: rgba(0, 0, 0, 0.8);
      color: #e0f7ff;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      cursor: pointer;
      box-shadow:
        0 0 15px rgba(0, 234, 255, 0.5),
        0 0 30px rgba(0, 234, 255, 0.3);
      transition: all 0.3s ease;
    }

    .btn:hover {
      background: rgba(0, 234, 255, 0.2);
      transform: translateY(-3px);
      box-shadow:
        0 0 25px rgba(0, 234, 255, 0.8),
        0 0 50px rgba(0, 234, 255, 0.5);
    }

    .btn:active {
      transform: translateY(0);
    }

    /* モーダル */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 20px;
    }

    .modal.hidden {
      display: none;
    }

    .modal-content {
      background: radial-gradient(ellipse at top, #0a1525 0%, #000000 70%);
      border: 2px solid rgba(0, 234, 255, 0.6);
      border-radius: 20px;
      padding: 40px;
      max-width: 500px;
      width: 100%;
      box-shadow:
        0 0 50px rgba(0, 234, 255, 0.5),
        0 0 100px rgba(0, 234, 255, 0.2),
        inset 0 0 30px rgba(0, 0, 0, 0.9);
    }

    .modal-title {
      font-size: 1.8rem;
      font-weight: 700;
      text-align: center;
      color: var(--neon-blue);
      text-shadow: 0 0 15px rgba(0, 234, 255, 0.8);
      margin-bottom: 30px;
      text-transform: uppercase;
      letter-spacing: 0.15em;
    }

    .mode-buttons, .level-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .mode-btn, .level-btn {
      padding: 18px 28px;
      font-size: 1.1rem;
      font-family: inherit;
      border-radius: 12px;
      border: 2px solid rgba(0, 234, 255, 0.5);
      background: rgba(0, 234, 255, 0.1);
      color: #e0f7ff;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-weight: 500;
    }

    .mode-btn:hover, .level-btn:hover {
      border-color: rgba(0, 234, 255, 0.9);
      background: rgba(0, 234, 255, 0.25);
      box-shadow: 0 0 25px rgba(0, 234, 255, 0.6);
      transform: translateY(-3px) scale(1.02);
    }

    .level-btn.beginner { border-color: rgba(74, 255, 0, 0.5); }
    .level-btn.beginner:hover {
      border-color: rgba(74, 255, 0, 0.9);
      background: rgba(74, 255, 0, 0.2);
      box-shadow: 0 0 25px rgba(74, 255, 0, 0.6);
    }

    .level-btn.intermediate { border-color: rgba(255, 200, 0, 0.5); }
    .level-btn.intermediate:hover {
      border-color: rgba(255, 200, 0, 0.9);
      background: rgba(255, 200, 0, 0.2);
      box-shadow: 0 0 25px rgba(255, 200, 0, 0.6);
    }

    .level-btn.advanced { border-color: rgba(255, 100, 0, 0.5); }
    .level-btn.advanced:hover {
      border-color: rgba(255, 100, 0, 0.9);
      background: rgba(255, 100, 0, 0.2);
      box-shadow: 0 0 25px rgba(255, 100, 0, 0.6);
    }

    .level-btn.pro { border-color: rgba(191, 0, 255, 0.5); }
    .level-btn.pro:hover {
      border-color: rgba(191, 0, 255, 0.9);
      background: rgba(191, 0, 255, 0.2);
      box-shadow: 0 0 25px rgba(191, 0, 255, 0.6);
    }

    .level-description {
      font-size: 0.8rem;
      opacity: 0.6;
      margin-top: 6px;
      font-family: system-ui, sans-serif;
      text-transform: none;
      letter-spacing: 0;
    }

    .mode-btn.how-to-play {
      border-color: rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.05);
    }

    .mode-btn.how-to-play:hover {
      border-color: rgba(255, 255, 255, 0.6);
      background: rgba(255, 255, 255, 0.1);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
    }

    /* 遊び方モーダル */
    .howto-content {
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .howto-body {
      text-align: left;
      font-family: system-ui, sans-serif;
    }

    .howto-section {
      margin-bottom: 24px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(0, 234, 255, 0.2);
    }

    .howto-section:last-child {
      border-bottom: none;
      margin-bottom: 10px;
    }

    .howto-section h3 {
      color: var(--neon-blue);
      font-size: 1.1rem;
      margin-bottom: 12px;
      font-family: 'Orbitron', sans-serif;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .howto-section p {
      line-height: 1.7;
      opacity: 0.9;
    }

    .howto-section ul {
      padding-left: 20px;
      line-height: 1.8;
    }

    .howto-section li {
      margin-bottom: 8px;
      opacity: 0.9;
    }

    .howto-section strong {
      color: var(--neon-green);
    }

    .piece-demo {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 15px 0;
    }

    .demo-piece {
      border-radius: 50%;
      background: radial-gradient(circle at 30% 20%, #fff 0%, #00eaff 30%, #004a5a 80%);
      box-shadow: 0 0 15px rgba(0, 234, 255, 0.7);
    }

    .demo-piece.large { width: 50px; height: 50px; }
    .demo-piece.medium { width: 38px; height: 38px; }
    .demo-piece.small { width: 26px; height: 26px; }

    .tip {
      color: var(--neon-gold);
      font-size: 0.9rem;
    }

    .back-btn {
      margin-top: 20px;
      width: 100%;
    }

    /* 勝利エフェクト */
    .victory-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    .victory-overlay.active {
      opacity: 1;
      pointer-events: auto;
    }

    .victory-text {
      font-size: 4rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      animation: victoryPulse 1s ease-in-out infinite;
    }

    .victory-text.p1 {
      color: var(--neon-blue);
      text-shadow:
        0 0 20px rgba(0, 234, 255, 1),
        0 0 40px rgba(0, 234, 255, 0.8),
        0 0 80px rgba(0, 234, 255, 0.6);
    }

    .victory-text.p2 {
      color: var(--neon-green);
      text-shadow:
        0 0 20px rgba(74, 255, 0, 1),
        0 0 40px rgba(74, 255, 0, 0.8),
        0 0 80px rgba(74, 255, 0, 0.6);
    }

    @keyframes victoryPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .victory-sub {
      font-size: 1.5rem;
      margin-top: 20px;
      opacity: 0.8;
    }

    .victory-btn {
      margin-top: 40px;
      animation: victoryBtnPulse 2s ease-in-out infinite;
    }

    @keyframes victoryBtnPulse {
      0%, 100% { box-shadow: 0 0 15px rgba(0, 234, 255, 0.5), 0 0 30px rgba(0, 234, 255, 0.3); }
      50% { box-shadow: 0 0 25px rgba(0, 234, 255, 0.8), 0 0 50px rgba(0, 234, 255, 0.5); }
    }

    /* AI思考中インジケーター */
    .thinking-indicator {
      position: absolute;
      top: 160px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      align-items: center;
      gap: 10px;
      padding: 10px 20px;
      background: rgba(0, 5, 15, 0.9);
      border: 1px solid rgba(191, 0, 255, 0.5);
      border-radius: 20px;
      color: var(--neon-purple);
    }

    .thinking-indicator.active {
      display: flex;
    }

    .thinking-dots {
      display: flex;
      gap: 4px;
    }

    .thinking-dots span {
      width: 8px;
      height: 8px;
      background: var(--neon-purple);
      border-radius: 50%;
      animation: thinkingBounce 1.4s ease-in-out infinite;
    }

    .thinking-dots span:nth-child(1) { animation-delay: 0s; }
    .thinking-dots span:nth-child(2) { animation-delay: 0.2s; }
    .thinking-dots span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes thinkingBounce {
      0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
      40% { transform: scale(1); opacity: 1; }
    }

    /* レスポンシブ */
    @media (max-width: 900px) {
      .reserve-panel {
        position: absolute;
        top: auto;
        bottom: 100px;
        transform: none;
        min-width: auto;
        padding: 15px;
      }

      .reserve-panel.p1 { left: 20px; right: auto; }
      .reserve-panel.p2 { right: 20px; left: auto; }

      .reserve-pieces {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
      }

      h1 { font-size: 1.5rem; }
      .status-bar { min-width: auto; padding: 10px 15px; font-size: 0.85rem; }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <canvas id="game-canvas"></canvas>

  <div class="ui-overlay">
    <div class="header">
      <h1>Gozigen Gokigenz</h1>
      <div class="subtitle">3D Neon Edition - Gobble Your Way to Victory</div>
    </div>

    <div class="status-bar" id="status-bar">
      <div class="status-main" id="status-main"></div>
      <div class="status-message" id="status-message"></div>
    </div>

    <div class="thinking-indicator" id="thinking-indicator">
      <span>AI Thinking</span>
      <div class="thinking-dots">
        <span></span><span></span><span></span>
      </div>
    </div>

    <div class="reserve-panel p1" id="reserve-p1">
      <div class="reserve-label">Player 1 (Blue)</div>
      <div class="reserve-pieces" id="reserve-pieces-p1"></div>
    </div>

    <div class="reserve-panel p2" id="reserve-p2">
      <div class="reserve-label">Player 2 (Green)</div>
      <div class="reserve-pieces" id="reserve-pieces-p2"></div>
    </div>

    <div class="control-row">
      <button class="btn" id="btn-new-game">New Game</button>
    </div>

    <div class="victory-overlay" id="victory-overlay">
      <div class="victory-text" id="victory-text"></div>
      <div class="victory-sub" id="victory-sub"></div>
      <button class="btn victory-btn" id="victory-new-game">New Game</button>
    </div>
  </div>

  <!-- モーダル -->
  <div class="modal" id="mode-modal">
    <div class="modal-content">
      <div class="modal-title">Select Game Mode</div>
      <div class="mode-buttons">
        <button class="mode-btn" onclick="selectMode('2P')">
          2 Players
          <div class="level-description">対人戦 - 同じ端末で2人で対戦</div>
        </button>
        <button class="mode-btn" onclick="selectMode('CPU')">
          vs Computer
          <div class="level-description">CPU対戦 - コンピューターと対戦</div>
        </button>
        <button class="mode-btn how-to-play" onclick="showHowToPlay()">
          How to Play
          <div class="level-description">遊び方を見る</div>
        </button>
      </div>
    </div>
  </div>

  <!-- 遊び方モーダル -->
  <div class="modal hidden" id="howto-modal">
    <div class="modal-content howto-content">
      <div class="modal-title">How to Play</div>
      <div class="howto-body">
        <div class="howto-section">
          <h3>ゲーム概要</h3>
          <p>「ゴブレットゴブラーズ」を元にした3目並べゲームです。<br>
          自分の駒を縦・横・斜めに3つ並べたら勝ち！</p>
        </div>

        <div class="howto-section">
          <h3>駒について</h3>
          <div class="piece-demo">
            <div class="demo-piece large"></div>
            <div class="demo-piece medium"></div>
            <div class="demo-piece small"></div>
          </div>
          <p>各プレイヤーは大・中・小の駒を2個ずつ（計6個）持っています。</p>
        </div>

        <div class="howto-section">
          <h3>基本ルール</h3>
          <ul>
            <li>自分のターンに、手持ちの駒を盤上に置くか、盤上の自分の駒を移動させます</li>
            <li>空いているマスには、どのサイズの駒でも置けます</li>
            <li><strong>かぶせルール：</strong>より大きい駒は、小さい駒の上にかぶせられます（自分の駒でも相手の駒でもOK！）</li>
            <li>かぶせられた駒は見えなくなりますが、消えたわけではありません</li>
            <li>上の駒が移動すると、下の駒が再び現れます</li>
          </ul>
        </div>

        <div class="howto-section">
          <h3>操作方法</h3>
          <ul>
            <li><strong>駒の選択：</strong>左右の手持ちエリアから駒をクリック、または盤上の自分の駒をクリック</li>
            <li><strong>駒の配置：</strong>駒を選択した状態で、盤上のマスをクリック</li>
            <li><strong>選択解除：</strong>同じ駒をもう一度クリック</li>
          </ul>
        </div>

        <div class="howto-section">
          <h3>勝利条件</h3>
          <p>盤面の最上面に見えている自分の駒を、縦・横・斜めのいずれかで3つ並べたら勝ち！<br>
          <span class="tip">※ヒント：相手の駒をかぶせて勝利を阻止したり、自分の駒を移動させて下から別の駒を出現させる戦略も有効です！</span></p>
        </div>
      </div>
      <button class="btn back-btn" onclick="hideHowToPlay()">戻る</button>
    </div>
  </div>

  <div class="modal hidden" id="level-modal">
    <div class="modal-content">
      <div class="modal-title">Select Difficulty</div>
      <div class="level-buttons">
        <button class="level-btn beginner" onclick="selectLevel('beginner')">
          初心者
          <div class="level-description">ランダムに手を選択 - 初めての方向け</div>
        </button>
        <button class="level-btn intermediate" onclick="selectLevel('intermediate')">
          中級
          <div class="level-description">基本戦略を使用 - 勝ち筋を見つけます</div>
        </button>
        <button class="level-btn advanced" onclick="selectLevel('advanced')">
          上級
          <div class="level-description">ミニマックス法 - 3手先を読みます</div>
        </button>
        <button class="level-btn pro" onclick="selectLevel('pro')">
          プロ
          <div class="level-description">α-β枝刈り搭載 - 5手先を完全読み</div>
        </button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ====================================
    // TRON風サウンドエンジン
    // ====================================
    let audioContext = null;
    let soundEnabled = true;
    let bgmPlaying = false;
    let bgmNodes = [];

    function initAudio() {
      if (audioContext) return;
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      } catch (e) {
        console.log('Web Audio API not supported');
        soundEnabled = false;
      }
    }

    document.addEventListener('click', () => {
      if (!audioContext) initAudio();
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
      }
      if (!bgmPlaying) {
        startBGM();
      }
    }, { once: true });

    // BGMなし（効果音のみ）
    function startBGM() {
      // BGMは無効化
    }

    function stopBGM() {
      bgmPlaying = false;
    }

    function setBGMVolume(level) {
      // BGMなし
    }

    function playSound(type) {
      if (!audioContext || !soundEnabled) return;

      switch (type) {
        case 'select':
          playSynthTone(880, 0.08, 'sine', 0.3, 0.02);
          playSynthTone(1320, 0.06, 'sine', 0.2, 0.04);
          break;
        case 'place':
          playSynthTone(220, 0.15, 'triangle', 0.4, 0);
          playSynthTone(110, 0.2, 'sawtooth', 0.2, 0.05);
          playNoise(0.1, 0.15);
          break;
        case 'move':
          playSweep(400, 800, 0.3, 'sine', 0.25);
          break;
        case 'gobble':
          playSynthTone(150, 0.1, 'sawtooth', 0.4, 0);
          playSynthTone(300, 0.15, 'square', 0.3, 0.05);
          playSynthTone(100, 0.2, 'triangle', 0.3, 0.1);
          playNoise(0.15, 0.1);
          break;
        case 'error':
          playSynthTone(200, 0.15, 'sawtooth', 0.3, 0);
          playSynthTone(210, 0.15, 'sawtooth', 0.3, 0.02);
          break;
        case 'win':
          playSynthTone(523, 0.2, 'sine', 0.4, 0);
          playSynthTone(659, 0.2, 'sine', 0.4, 0.15);
          playSynthTone(784, 0.2, 'sine', 0.4, 0.3);
          playSynthTone(1047, 0.4, 'sine', 0.5, 0.45);
          playSweep(200, 1200, 0.8, 'sine', 0.15);
          break;
        case 'turn':
          playSynthTone(660, 0.05, 'sine', 0.2, 0);
          playSynthTone(880, 0.05, 'sine', 0.15, 0.03);
          break;
        case 'start':
          playSweep(100, 600, 0.4, 'sawtooth', 0.3);
          playSynthTone(440, 0.15, 'sine', 0.3, 0.2);
          playSynthTone(550, 0.15, 'sine', 0.3, 0.3);
          playSynthTone(660, 0.2, 'sine', 0.35, 0.4);
          break;
      }
    }

    function playSynthTone(freq, duration, waveform, volume, delay) {
      if (!audioContext) return;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();
      osc.type = waveform;
      osc.frequency.value = freq;
      filter.type = 'lowpass';
      filter.frequency.value = 3000;
      filter.Q.value = 1;
      const now = audioContext.currentTime + delay;
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(volume * 0.3, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioContext.destination);
      osc.start(now);
      osc.stop(now + duration + 0.1);
    }

    function playSweep(startFreq, endFreq, duration, waveform, volume) {
      if (!audioContext) return;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.type = waveform;
      const now = audioContext.currentTime;
      osc.frequency.setValueAtTime(startFreq, now);
      osc.frequency.exponentialRampToValueAtTime(endFreq, now + duration);
      gain.gain.setValueAtTime(volume * 0.3, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      osc.connect(gain);
      gain.connect(audioContext.destination);
      osc.start(now);
      osc.stop(now + duration + 0.1);
    }

    function playNoise(duration, volume) {
      if (!audioContext) return;
      const bufferSize = audioContext.sampleRate * duration;
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * 0.5;
      }
      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;
      const gain = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 1000;
      filter.Q.value = 0.5;
      const now = audioContext.currentTime;
      gain.gain.setValueAtTime(volume * 0.2, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(audioContext.destination);
      noise.start(now);
      noise.stop(now + duration);
    }

    // ====================================
    // Three.js 3D Setup
    // ====================================
    let scene, camera, renderer;
    let boardGroup, cellMeshes = [], pieceMeshes = {};
    let particleSystem, glowLights = [];
    let raycaster, mouse;
    let clock = new THREE.Clock();

    const COLORS = {
      p1: 0x00eaff,
      p2: 0x4aff00,
      board: 0x0a1525,
      cell: 0x102030,
      cellHover: 0x1a3050,
      grid: 0x00eaff,
      winning: 0xffd700
    };

    function init3D() {
      const canvas = document.getElementById('game-canvas');
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000510, 0.02);
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 8, 10);
      camera.lookAt(0, 0, 0);
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      setupLights();
      createBoard();
      createParticles();
      window.addEventListener('resize', onWindowResize);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('click', onClick3D);
      animate();
    }

    function setupLights() {
      const ambient = new THREE.AmbientLight(0x101520, 0.5);
      scene.add(ambient);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(5, 10, 5);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      scene.add(dirLight);
      const blueLight = new THREE.PointLight(COLORS.p1, 1, 20);
      blueLight.position.set(-5, 5, -5);
      scene.add(blueLight);
      glowLights.push(blueLight);
      const greenLight = new THREE.PointLight(COLORS.p2, 1, 20);
      greenLight.position.set(5, 5, 5);
      scene.add(greenLight);
      glowLights.push(greenLight);
      const rimLight = new THREE.PointLight(0xbf00ff, 0.5, 15);
      rimLight.position.set(0, -3, 0);
      scene.add(rimLight);
    }

    function createBoard() {
      boardGroup = new THREE.Group();
      scene.add(boardGroup);
      const baseGeom = new THREE.BoxGeometry(8, 0.5, 8);
      const baseMat = new THREE.MeshStandardMaterial({
        color: COLORS.board, metalness: 0.8, roughness: 0.2, transparent: true, opacity: 0.9
      });
      const baseMesh = new THREE.Mesh(baseGeom, baseMat);
      baseMesh.position.y = -0.3;
      baseMesh.receiveShadow = true;
      boardGroup.add(baseMesh);

      const gridMat = new THREE.LineBasicMaterial({ color: COLORS.grid, transparent: true, opacity: 0.6 });
      for (let i = 0; i <= 3; i++) {
        const pos = -3 + i * 2;
        const hPoints = [new THREE.Vector3(-3, 0.01, pos), new THREE.Vector3(3, 0.01, pos)];
        const hGeom = new THREE.BufferGeometry().setFromPoints(hPoints);
        boardGroup.add(new THREE.Line(hGeom, gridMat));
        const vPoints = [new THREE.Vector3(pos, 0.01, -3), new THREE.Vector3(pos, 0.01, 3)];
        const vGeom = new THREE.BufferGeometry().setFromPoints(vPoints);
        boardGroup.add(new THREE.Line(vGeom, gridMat));
      }

      cellMeshes = [];
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          const cellGeom = new THREE.PlaneGeometry(1.9, 1.9);
          const cellMat = new THREE.MeshStandardMaterial({
            color: COLORS.cell, metalness: 0.5, roughness: 0.5, transparent: true, opacity: 0.3
          });
          const cellMesh = new THREE.Mesh(cellGeom, cellMat);
          cellMesh.rotation.x = -Math.PI / 2;
          cellMesh.position.set(-2 + c * 2, 0.02, -2 + r * 2);
          cellMesh.userData = { row: r, col: c };
          boardGroup.add(cellMesh);
          cellMeshes.push(cellMesh);
        }
      }
    }

    function createParticles() {
      const particleCount = 500;
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 30;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 20;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 30;
        const color = Math.random() > 0.5 ? new THREE.Color(COLORS.p1) : new THREE.Color(COLORS.p2);
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
      }
      const particleGeom = new THREE.BufferGeometry();
      particleGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeom.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      // 丸いパーティクル用のテクスチャを作成
      const canvas = document.createElement('canvas');
      canvas.width = 32;
      canvas.height = 32;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
      gradient.addColorStop(0, 'rgba(255,255,255,1)');
      gradient.addColorStop(0.3, 'rgba(255,255,255,0.8)');
      gradient.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 32, 32);
      const particleTexture = new THREE.CanvasTexture(canvas);

      const particleMat = new THREE.PointsMaterial({
        size: 0.15,
        map: particleTexture,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      particleSystem = new THREE.Points(particleGeom, particleMat);
      scene.add(particleSystem);
    }

    function createPieceMesh(pieceId, owner, size) {
      const sizeMap = { large: 0.7, medium: 0.5, small: 0.35 };
      const radius = sizeMap[size];
      const geom = new THREE.SphereGeometry(radius, 32, 24);
      geom.scale(1, 0.7, 1);
      const color = owner === 1 ? COLORS.p1 : COLORS.p2;
      const mat = new THREE.MeshStandardMaterial({
        color: color, metalness: 0.4, roughness: 0.3, emissive: color, emissiveIntensity: 0.3
      });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.castShadow = true;
      mesh.userData = { pieceId, owner, size };
      const ringGeom = new THREE.TorusGeometry(radius * 0.9, 0.03, 16, 32);
      const ringMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.6 });
      const ring = new THREE.Mesh(ringGeom, ringMat);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = -radius * 0.3;
      mesh.add(ring);
      const innerGeom = new THREE.SphereGeometry(radius * 0.3, 16, 16);
      const innerMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
      const inner = new THREE.Mesh(innerGeom, innerMat);
      inner.position.set(-radius * 0.2, radius * 0.2, radius * 0.3);
      mesh.add(inner);
      return mesh;
    }

    function placePiece3D(pieceId, row, col, animate = true) {
      const piece = gameState.pieces[pieceId];
      let mesh = pieceMeshes[pieceId];
      if (!mesh) {
        mesh = createPieceMesh(pieceId, piece.owner, piece.size);
        pieceMeshes[pieceId] = mesh;
        scene.add(mesh);
      }
      const targetX = -2 + col * 2;
      const targetZ = -2 + row * 2;
      const stack = gameState.board[row][col];
      const stackIndex = stack.indexOf(pieceId);
      const targetY = 0.3 + stackIndex * 0.2;
      if (animate) {
        const startY = 5;
        mesh.position.set(targetX, startY, targetZ);
        mesh.scale.set(0.1, 0.1, 0.1);
        const duration = 500;
        const startTime = Date.now();
        function animateDrop() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const eased = 1 - Math.pow(1 - progress, 3);
          mesh.position.y = startY + (targetY - startY) * eased;
          mesh.scale.setScalar(0.1 + 0.9 * eased);
          if (progress < 1) {
            requestAnimationFrame(animateDrop);
          } else {
            createLandingParticles(targetX, targetY, targetZ, piece.owner);
          }
        }
        animateDrop();
      } else {
        mesh.position.set(targetX, targetY, targetZ);
      }
      mesh.visible = true;
    }

    function movePiece3D(pieceId, fromRow, fromCol, toRow, toCol) {
      const mesh = pieceMeshes[pieceId];
      if (!mesh) return;
      const piece = gameState.pieces[pieceId];
      const targetX = -2 + toCol * 2;
      const targetZ = -2 + toRow * 2;
      const stack = gameState.board[toRow][toCol];
      const stackIndex = stack.indexOf(pieceId);
      const targetY = 0.3 + stackIndex * 0.2;
      const startPos = mesh.position.clone();
      const duration = 600;
      const startTime = Date.now();
      const arcHeight = 2;
      function animateMove() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
        mesh.position.x = startPos.x + (targetX - startPos.x) * eased;
        mesh.position.z = startPos.z + (targetZ - startPos.z) * eased;
        mesh.position.y = startPos.y + (targetY - startPos.y) * eased + Math.sin(progress * Math.PI) * arcHeight;
        mesh.rotation.y = progress * Math.PI * 2;
        if (progress < 1) {
          requestAnimationFrame(animateMove);
        } else {
          mesh.rotation.y = 0;
          createLandingParticles(targetX, targetY, targetZ, piece.owner);
        }
      }
      animateMove();
    }

    function createLandingParticles(x, y, z, owner) {
      const color = owner === 1 ? COLORS.p1 : COLORS.p2;
      const particleCount = 20;
      for (let i = 0; i < particleCount; i++) {
        const geom = new THREE.SphereGeometry(0.05, 8, 8);
        const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1 });
        const particle = new THREE.Mesh(geom, mat);
        particle.position.set(x, y, z);
        const angle = (i / particleCount) * Math.PI * 2;
        const velocity = { x: Math.cos(angle) * 0.1, y: Math.random() * 0.1 + 0.05, z: Math.sin(angle) * 0.1 };
        scene.add(particle);
        const startTime = Date.now();
        function animateParticle() {
          const elapsed = Date.now() - startTime;
          if (elapsed > 500) { scene.remove(particle); return; }
          const progress = elapsed / 500;
          particle.position.x += velocity.x;
          particle.position.y += velocity.y - progress * 0.02;
          particle.position.z += velocity.z;
          particle.material.opacity = 1 - progress;
          particle.scale.setScalar(1 - progress * 0.5);
          requestAnimationFrame(animateParticle);
        }
        animateParticle();
      }
    }

    function highlightWinningLine3D(line, owner) {
      const winColor = owner === 1 ? COLORS.p1 : COLORS.p2;

      // 勝利ラインのビーム
      const points = line.map(([r, c]) => new THREE.Vector3(-2 + c * 2, 0.5, -2 + r * 2));
      const lineGeom = new THREE.BufferGeometry().setFromPoints(points);
      const lineMat = new THREE.LineBasicMaterial({ color: COLORS.winning, linewidth: 3, transparent: true, opacity: 0.8 });
      const winLine = new THREE.Line(lineGeom, lineMat);
      winLine.userData.isWinningLine = true;
      scene.add(winLine);

      // セルを光らせる
      line.forEach(([r, c]) => {
        const cellMesh = cellMeshes.find(m => m.userData.row === r && m.userData.col === c);
        if (cellMesh) {
          cellMesh.material.color.setHex(COLORS.winning);
          cellMesh.material.emissive = new THREE.Color(COLORS.winning);
          cellMesh.material.emissiveIntensity = 0.5;
          cellMesh.material.opacity = 0.6;
        }
      });

      const currentSessionId = gameState.sessionId;

      // 勝利パーティクル爆発
      createVictoryExplosion(line, owner, currentSessionId);

      // 勝利駒のジャンプとパルス
      line.forEach(([r, c], index) => {
        const stack = gameState.board[r][c];
        if (stack.length > 0) {
          const topId = stack[stack.length - 1];
          const mesh = pieceMeshes[topId];
          if (mesh) {
            const startY = mesh.position.y;
            const startTime = Date.now();
            const jumpDelay = index * 150; // 順番にジャンプ

            function animateWinningPiece() {
              if (!gameState.gameOver || gameState.sessionId !== currentSessionId || !pieceMeshes[topId]) return;

              const elapsed = Date.now() - startTime;
              const jumpElapsed = Math.max(0, elapsed - jumpDelay);

              // ジャンプアニメーション
              const jumpCycle = jumpElapsed % 1000;
              const jumpProgress = jumpCycle / 1000;
              const jumpHeight = Math.sin(jumpProgress * Math.PI) * 1.5;
              mesh.position.y = startY + jumpHeight;

              // 回転
              mesh.rotation.y = elapsed * 0.003;

              // パルススケール
              const pulseScale = 1 + Math.sin(elapsed / 150) * 0.15;
              mesh.scale.setScalar(pulseScale);

              // グロー強度
              mesh.material.emissiveIntensity = 0.5 + Math.sin(elapsed / 100) * 0.3;

              requestAnimationFrame(animateWinningPiece);
            }
            animateWinningPiece();
          }
        }
      });

      // 連続パーティクルストリーム
      createVictoryParticleStream(line, owner, currentSessionId);

      // 光の柱
      createLightPillars(line, owner, currentSessionId);
    }

    function createVictoryExplosion(line, owner, sessionId) {
      const color = owner === 1 ? COLORS.p1 : COLORS.p2;

      line.forEach(([r, c]) => {
        const x = -2 + c * 2;
        const z = -2 + r * 2;

        // 大量のパーティクル
        for (let i = 0; i < 50; i++) {
          const geom = new THREE.SphereGeometry(0.08, 8, 8);
          const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1 });
          const particle = new THREE.Mesh(geom, mat);
          particle.position.set(x, 0.5, z);

          const angle = Math.random() * Math.PI * 2;
          const elevation = Math.random() * Math.PI - Math.PI / 2;
          const speed = 0.1 + Math.random() * 0.2;
          const velocity = {
            x: Math.cos(angle) * Math.cos(elevation) * speed,
            y: Math.sin(elevation) * speed + 0.1,
            z: Math.sin(angle) * Math.cos(elevation) * speed
          };

          scene.add(particle);

          const startTime = Date.now();
          function animate() {
            const elapsed = Date.now() - startTime;
            if (elapsed > 1500) { scene.remove(particle); return; }

            const progress = elapsed / 1500;
            particle.position.x += velocity.x;
            particle.position.y += velocity.y - progress * 0.01;
            particle.position.z += velocity.z;
            velocity.x *= 0.98;
            velocity.z *= 0.98;
            particle.material.opacity = 1 - progress;
            particle.scale.setScalar(1 + progress);

            requestAnimationFrame(animate);
          }
          animate();
        }
      });
    }

    function createVictoryParticleStream(line, owner, sessionId) {
      const color = owner === 1 ? COLORS.p1 : COLORS.p2;
      let streamActive = true;

      function spawnParticle() {
        if (!gameState.gameOver || gameState.sessionId !== sessionId) {
          streamActive = false;
          return;
        }

        const [r, c] = line[Math.floor(Math.random() * line.length)];
        const x = -2 + c * 2 + (Math.random() - 0.5);
        const z = -2 + r * 2 + (Math.random() - 0.5);

        const geom = new THREE.SphereGeometry(0.05, 6, 6);
        const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
        const particle = new THREE.Mesh(geom, mat);
        particle.position.set(x, 0, z);
        scene.add(particle);

        const startTime = Date.now();
        function animate() {
          const elapsed = Date.now() - startTime;
          if (elapsed > 2000) { scene.remove(particle); return; }
          const progress = elapsed / 2000;
          particle.position.y = progress * 8;
          particle.material.opacity = 0.8 * (1 - progress);
          particle.scale.setScalar(1 - progress * 0.5);
          requestAnimationFrame(animate);
        }
        animate();

        if (streamActive) {
          setTimeout(spawnParticle, 50);
        }
      }
      spawnParticle();
    }

    function createLightPillars(line, owner, sessionId) {
      const color = owner === 1 ? COLORS.p1 : COLORS.p2;

      line.forEach(([r, c]) => {
        const x = -2 + c * 2;
        const z = -2 + r * 2;

        // 光の柱（シリンダー）
        const pillarGeom = new THREE.CylinderGeometry(0.3, 0.5, 10, 16, 1, true);
        const pillarMat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.3,
          side: THREE.DoubleSide
        });
        const pillar = new THREE.Mesh(pillarGeom, pillarMat);
        pillar.position.set(x, 5, z);
        pillar.userData.isWinningLine = true;
        scene.add(pillar);

        const startTime = Date.now();
        function animatePillar() {
          if (!gameState.gameOver || gameState.sessionId !== sessionId) {
            scene.remove(pillar);
            return;
          }
          const elapsed = Date.now() - startTime;
          pillar.rotation.y = elapsed * 0.002;
          pillar.material.opacity = 0.2 + Math.sin(elapsed / 200) * 0.15;
          pillar.scale.x = 1 + Math.sin(elapsed / 300) * 0.2;
          pillar.scale.z = 1 + Math.sin(elapsed / 300) * 0.2;
          requestAnimationFrame(animatePillar);
        }
        animatePillar();
      });
    }

    function updatePieceVisibility() {
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          const stack = gameState.board[r][c];
          stack.forEach((pieceId, index) => {
            const mesh = pieceMeshes[pieceId];
            if (mesh) {
              mesh.material.opacity = (index === stack.length - 1) ? 1 : 0.3;
            }
          });
        }
      }
    }

    function resetBoard3D() {
      Object.values(pieceMeshes).forEach(mesh => { scene.remove(mesh); });
      pieceMeshes = {};
      cellMeshes.forEach(cell => {
        cell.material.color.setHex(COLORS.cell);
        cell.material.emissive = new THREE.Color(0x000000);
        cell.material.emissiveIntensity = 0;
        cell.material.opacity = 0.3;
      });
      scene.children = scene.children.filter(child => !child.userData?.isWinningLine);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    let hoveredCell = null;
    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(cellMeshes);
      if (hoveredCell && hoveredCell !== intersects[0]?.object) {
        if (!gameState.winningLine || !gameState.winningLine.some(([r,c]) =>
            hoveredCell.userData.row === r && hoveredCell.userData.col === c)) {
          hoveredCell.material.color.setHex(COLORS.cell);
          hoveredCell.material.opacity = 0.3;
        }
      }
      if (intersects.length > 0 && !gameState.gameOver && gameState.selectedPieceId !== null) {
        hoveredCell = intersects[0].object;
        hoveredCell.material.color.setHex(COLORS.cellHover);
        hoveredCell.material.opacity = 0.5;
        document.body.style.cursor = 'pointer';
      } else {
        hoveredCell = null;
        document.body.style.cursor = 'default';
      }
    }

    function onClick3D(event) {
      if (gameState.gameOver || gameState.isAIThinking) return;
      raycaster.setFromCamera(mouse, camera);

      // 盤上の駒をクリックして選択
      const pieceMeshArray = Object.values(pieceMeshes).filter(m => m.visible);
      const pieceIntersects = raycaster.intersectObjects(pieceMeshArray, true);
      if (pieceIntersects.length > 0 && gameState.selectedPieceId === null) {
        let target = pieceIntersects[0].object;
        while (target && !target.userData.pieceId) { target = target.parent; }
        if (target && target.userData.pieceId) {
          const piece = gameState.pieces[target.userData.pieceId];
          if (piece.owner === gameState.currentPlayer && piece.row !== null) {
            const stack = gameState.board[piece.row][piece.col];
            if (stack[stack.length - 1] === piece.id) {
              gameState.selectedPieceId = piece.id;
              setStatusMessage('移動先のセルを選択');
              playSound('select');
              renderReserves();
              return;
            }
          }
        }
      }

      // セルをクリックして配置
      const cellIntersects = raycaster.intersectObjects(cellMeshes);
      if (cellIntersects.length > 0 && gameState.selectedPieceId !== null) {
        const cell = cellIntersects[0].object;
        const { row, col } = cell.userData;
        handleCellClick(row, col);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const time = clock.getElapsedTime();
      if (particleSystem) { particleSystem.rotation.y += delta * 0.05; }
      camera.position.x = Math.sin(time * 0.2) * 0.5;
      camera.position.z = 10 + Math.cos(time * 0.15) * 0.3;
      camera.lookAt(0, 0, 0);
      glowLights.forEach((light, i) => { light.intensity = 0.8 + Math.sin(time * 2 + i) * 0.3; });
      if (!gameState.gameOver) {
        const targetRotation = gameState.currentPlayer === 1 ? -0.05 : 0.05;
        boardGroup.rotation.y += (targetRotation - boardGroup.rotation.y) * 0.02;
      }
      renderer.render(scene, camera);
    }

    // ====================================
    // ゲームロジック（完全書き直し）
    // ====================================
    const SIZE_RANK = { small: 1, medium: 2, large: 3 };

    // ゲーム状態（すべて1つのオブジェクトで管理）
    const gameState = {
      sessionId: 0,
      board: [],           // board[row][col] = [pieceId, pieceId, ...] (スタック)
      pieces: {},          // pieces[id] = { id, owner, size, row, col } (row/col = null なら手持ち)
      currentPlayer: 1,    // 1 = P1 (Blue), 2 = P2 (Green/AI)
      selectedPieceId: null,
      winner: null,
      winningLine: null,
      gameOver: false,
      gameMode: null,      // '2P' or 'CPU'
      aiLevel: null,
      isAIThinking: false
    };

    // DOM要素
    const statusMainEl = document.getElementById('status-main');
    const statusMsgEl = document.getElementById('status-message');
    const victoryOverlay = document.getElementById('victory-overlay');
    const victoryText = document.getElementById('victory-text');
    const victorySub = document.getElementById('victory-sub');
    const thinkingIndicator = document.getElementById('thinking-indicator');

    // ====================================
    // 初期化
    // ====================================
    function initBoard() {
      gameState.board = [];
      for (let r = 0; r < 3; r++) {
        const row = [];
        for (let c = 0; c < 3; c++) { row.push([]); }
        gameState.board.push(row);
      }
    }

    function initPieces() {
      gameState.pieces = {};
      const sizes = ['large', 'large', 'medium', 'medium', 'small', 'small'];
      [1, 2].forEach(owner => {
        sizes.forEach((size, i) => {
          const id = `P${owner}-${size}-${i}`;
          gameState.pieces[id] = { id, owner, size, row: null, col: null };
        });
      });
    }

    function newGame() {
      gameState.sessionId++;
      initBoard();
      initPieces();
      resetBoard3D();
      // 先攻後攻をランダムに決定（1 or 2）
      gameState.currentPlayer = Math.random() < 0.5 ? 1 : 2;
      gameState.selectedPieceId = null;
      gameState.winner = null;
      gameState.winningLine = null;
      gameState.gameOver = false;
      gameState.isAIThinking = false;
      victoryOverlay.classList.remove('active');
      renderReserves();
      updateStatusBar();
      const firstPlayerName = gameState.currentPlayer === 1 ? 'Player 1 (Blue)' :
        (gameState.gameMode === 'CPU' ? 'AI (Green)' : 'Player 2 (Green)');
      setStatusMessage(`${firstPlayerName} が先攻です！`);

      // CPUモードでAIが先攻の場合、AIに手番を渡す
      if (gameState.gameMode === 'CPU' && gameState.currentPlayer === 2) {
        setTimeout(() => aiMove(), 800);
      }
    }

    // ====================================
    // UI描画
    // ====================================
    function renderReserves() {
      const p1Container = document.getElementById('reserve-pieces-p1');
      const p2Container = document.getElementById('reserve-pieces-p2');
      p1Container.innerHTML = '';
      p2Container.innerHTML = '';
      const sizeOrder = { large: 0, medium: 1, small: 2 };
      Object.values(gameState.pieces)
        .filter(p => p.row === null)
        .sort((a, b) => sizeOrder[a.size] - sizeOrder[b.size])
        .forEach(piece => {
          const el = document.createElement('div');
          el.className = `reserve-piece p${piece.owner} ${piece.size}`;
          el.dataset.pieceId = piece.id;
          if (piece.id === gameState.selectedPieceId) { el.classList.add('selected'); }
          el.addEventListener('click', (e) => onReservePieceClick(e, piece.id));
          (piece.owner === 1 ? p1Container : p2Container).appendChild(el);
        });
    }

    function updateStatusBar() {
      const playerName = p => p === 1 ? 'Player 1 (Blue)' : (gameState.gameMode === 'CPU' ? 'AI (Green)' : 'Player 2 (Green)');
      if (gameState.winner) {
        statusMainEl.textContent = `${playerName(gameState.winner)} Wins!`;
        statusMainEl.className = `status-main p${gameState.winner}`;
      } else {
        statusMainEl.textContent = `${playerName(gameState.currentPlayer)} のターン`;
        statusMainEl.className = `status-main p${gameState.currentPlayer}`;
      }
    }

    function setStatusMessage(msg, isError = false) {
      statusMsgEl.textContent = msg || '';
      statusMsgEl.classList.toggle('error', !!isError);
    }

    function flashError(msg) {
      setStatusMessage(msg, true);
      playSound('error');
      setTimeout(() => { if (!gameState.winner) setStatusMessage(''); }, 1500);
    }

    function showVictory(winner) {
      const playerName = winner === 1 ? 'Player 1' : (gameState.gameMode === 'CPU' ? 'AI' : 'Player 2');
      victoryText.textContent = `${playerName} Wins!`;
      victoryText.className = `victory-text p${winner}`;
      victorySub.textContent = winner === 1 ? '青の勝利!' : '緑の支配!';
      victoryOverlay.classList.add('active');
    }

    // ====================================
    // イベントハンドラ
    // ====================================
    function onReservePieceClick(e, pieceId) {
      if (gameState.gameOver || gameState.isAIThinking) return;
      e.stopPropagation();
      const piece = gameState.pieces[pieceId];

      // 相手の駒は選択できない
      if (piece.owner !== gameState.currentPlayer) {
        flashError('相手の駒は選択できません');
        return;
      }

      // 同じ駒をクリックで選択解除
      if (gameState.selectedPieceId === pieceId) {
        gameState.selectedPieceId = null;
        setStatusMessage('');
      } else {
        gameState.selectedPieceId = pieceId;
        setStatusMessage('ボード上のセルをクリックして配置');
        playSound('select');
      }
      renderReserves();
    }

    function handleCellClick(row, col) {
      if (gameState.gameOver || gameState.isAIThinking) return;

      // 駒が選択されていない場合、盤上の自分の駒を選択
      if (gameState.selectedPieceId === null) {
        const stack = gameState.board[row][col];
        if (stack.length > 0) {
          const topId = stack[stack.length - 1];
          const topPiece = gameState.pieces[topId];
          if (topPiece.owner === gameState.currentPlayer) {
            gameState.selectedPieceId = topId;
            setStatusMessage('移動先のセルを選択');
            playSound('select');
            renderReserves();
            return;
          } else {
            flashError('相手の駒は選択できません');
            return;
          }
        }
        flashError('まず駒を選択してください');
        return;
      }

      const piece = gameState.pieces[gameState.selectedPieceId];

      // 現在のプレイヤーの駒かチェック
      if (piece.owner !== gameState.currentPlayer) {
        flashError('相手の駒は動かせません');
        gameState.selectedPieceId = null;
        renderReserves();
        return;
      }

      // 配置可能かチェック
      const destStack = gameState.board[row][col];
      const topId = destStack.length > 0 ? destStack[destStack.length - 1] : null;

      if (topId) {
        const topPiece = gameState.pieces[topId];
        if (SIZE_RANK[piece.size] <= SIZE_RANK[topPiece.size]) {
          flashError('同サイズ以上の駒の上には置けません');
          return;
        }
      }

      // 移動元から削除
      const isFromBoard = piece.row !== null;
      const fromRow = piece.row;
      const fromCol = piece.col;
      const isGobble = topId !== null;

      if (isFromBoard) {
        const fromStack = gameState.board[fromRow][fromCol];
        const idx = fromStack.indexOf(piece.id);
        if (idx !== -1) fromStack.splice(idx, 1);
      }

      // 移動先に追加
      destStack.push(piece.id);
      piece.row = row;
      piece.col = col;

      // 3D表示更新
      if (isFromBoard) {
        movePiece3D(piece.id, fromRow, fromCol, row, col);
      } else {
        placePiece3D(piece.id, row, col, true);
      }

      // 効果音
      if (isGobble) { playSound('gobble'); }
      else if (isFromBoard) { playSound('move'); }
      else { playSound('place'); }

      gameState.selectedPieceId = null;
      updatePieceVisibility();
      renderReserves();

      // 勝敗判定
      const result = checkWin();
      if (result) {
        gameState.winner = result.winner;
        gameState.winningLine = result.line;
        gameState.gameOver = true;
        highlightWinningLine3D(result.line, result.winner);
        playSound('win');
        setTimeout(() => showVictory(result.winner), 800);
      } else {
        // ターン交代
        gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
        setStatusMessage('');
        playSound('turn');

        // AI のターン
        if (gameState.gameMode === 'CPU' && gameState.currentPlayer === 2) {
          setTimeout(() => aiMove(), 600);
        }
      }
      updateStatusBar();
    }

    // ====================================
    // 勝敗判定
    // ====================================
    function checkWin() {
      const lines = [
        [[0,0],[0,1],[0,2]], [[1,0],[1,1],[1,2]], [[2,0],[2,1],[2,2]],
        [[0,0],[1,0],[2,0]], [[0,1],[1,1],[2,1]], [[0,2],[1,2],[2,2]],
        [[0,0],[1,1],[2,2]], [[0,2],[1,1],[2,0]]
      ];
      for (const line of lines) {
        const owners = line.map(([r, c]) => {
          const stack = gameState.board[r][c];
          if (stack.length === 0) return null;
          return gameState.pieces[stack[stack.length - 1]].owner;
        });
        if (owners[0] !== null && owners[0] === owners[1] && owners[1] === owners[2]) {
          return { winner: owners[0], line };
        }
      }
      return null;
    }

    // ボードのコピー（AI用）
    function copyBoard() {
      return gameState.board.map(row => row.map(stack => [...stack]));
    }

    function copyPieces() {
      const copy = {};
      for (const id in gameState.pieces) {
        copy[id] = { ...gameState.pieces[id] };
      }
      return copy;
    }

    // ====================================
    // モード選択
    // ====================================
    function selectMode(mode) {
      gameState.gameMode = mode;
      document.getElementById('mode-modal').classList.add('hidden');
      if (mode === 'CPU') {
        document.getElementById('level-modal').classList.remove('hidden');
      } else {
        startGame();
      }
    }

    function selectLevel(level) {
      gameState.aiLevel = level;
      document.getElementById('level-modal').classList.add('hidden');
      startGame();
    }

    function startGame() {
      newGame();
      playSound('start');
      setBGMVolume('game'); // ゲーム中はBGM音量を下げる
    }

    function showModeSelection() {
      victoryOverlay.classList.remove('active');
      gameState.gameOver = false;
      gameState.winner = null;
      gameState.winningLine = null;
      gameState.isAIThinking = false;
      document.getElementById('mode-modal').classList.remove('hidden');
      document.getElementById('level-modal').classList.add('hidden');
      document.getElementById('howto-modal').classList.add('hidden');
      // メニュー画面ではBGM音量を戻す
      setBGMVolume('menu');
    }

    function showHowToPlay() {
      document.getElementById('mode-modal').classList.add('hidden');
      document.getElementById('howto-modal').classList.remove('hidden');
    }

    function hideHowToPlay() {
      document.getElementById('howto-modal').classList.add('hidden');
      document.getElementById('mode-modal').classList.remove('hidden');
    }

    // ====================================
    // AI ロジック
    // ====================================
    function aiMove() {
      if (gameState.gameOver || gameState.isAIThinking) return;
      if (gameState.gameMode !== 'CPU' || gameState.currentPlayer !== 2) return;

      gameState.isAIThinking = true;
      thinkingIndicator.classList.add('active');
      setStatusMessage('AI思考中...');

      const thinkTime = gameState.aiLevel === 'pro' ? 1000 : (gameState.aiLevel === 'advanced' ? 600 : 400);

      setTimeout(() => {
        let move = null;
        switch (gameState.aiLevel) {
          case 'beginner': move = aiBeginnerMove(); break;
          case 'intermediate': move = aiIntermediateMove(); break;
          case 'advanced': move = aiAdvancedMove(); break;
          case 'pro': move = aiProMove(); break;
        }

        gameState.isAIThinking = false;
        thinkingIndicator.classList.remove('active');

        if (move) {
          executeMove(move.pieceId, move.toRow, move.toCol);
        }
      }, thinkTime);
    }

    // 合法手を取得（指定プレイヤー）
    function getAllLegalMoves(player, boardState, piecesState) {
      const moves = [];
      for (const id in piecesState) {
        const piece = piecesState[id];
        if (piece.owner !== player) continue;

        const isOnBoard = piece.row !== null;

        // 盤上にある駒は一番上のものだけ動かせる
        if (isOnBoard) {
          const stack = boardState[piece.row][piece.col];
          if (stack[stack.length - 1] !== piece.id) continue;
        }

        // 各セルへの配置をチェック
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 3; c++) {
            // 同じ位置への移動はスキップ
            if (isOnBoard && piece.row === r && piece.col === c) continue;

            const destStack = boardState[r][c];
            if (destStack.length === 0) {
              moves.push({ pieceId: piece.id, toRow: r, toCol: c });
            } else {
              const topId = destStack[destStack.length - 1];
              const topPiece = piecesState[topId];
              if (SIZE_RANK[piece.size] > SIZE_RANK[topPiece.size]) {
                moves.push({ pieceId: piece.id, toRow: r, toCol: c });
              }
            }
          }
        }
      }
      return moves;
    }

    // 手を適用（シミュレーション用）
    function applyMoveToState(move, boardState, piecesState) {
      const piece = piecesState[move.pieceId];
      const oldRow = piece.row;
      const oldCol = piece.col;

      // 元の位置から削除
      if (oldRow !== null) {
        const fromStack = boardState[oldRow][oldCol];
        const idx = fromStack.indexOf(piece.id);
        if (idx !== -1) fromStack.splice(idx, 1);
      }

      // 新しい位置に追加
      boardState[move.toRow][move.toCol].push(piece.id);
      piece.row = move.toRow;
      piece.col = move.toCol;

      return { pieceId: piece.id, oldRow, oldCol };
    }

    // 手を元に戻す（シミュレーション用）
    function undoMoveFromState(undoInfo, boardState, piecesState) {
      const piece = piecesState[undoInfo.pieceId];
      const currentRow = piece.row;
      const currentCol = piece.col;

      // 現在位置から削除
      const currentStack = boardState[currentRow][currentCol];
      const idx = currentStack.indexOf(piece.id);
      if (idx !== -1) currentStack.splice(idx, 1);

      // 元の位置に戻す
      if (undoInfo.oldRow !== null) {
        boardState[undoInfo.oldRow][undoInfo.oldCol].push(piece.id);
      }
      piece.row = undoInfo.oldRow;
      piece.col = undoInfo.oldCol;
    }

    // 勝者を判定（シミュレーション用）
    function checkWinFromState(boardState, piecesState) {
      const lines = [
        [[0,0],[0,1],[0,2]], [[1,0],[1,1],[1,2]], [[2,0],[2,1],[2,2]],
        [[0,0],[1,0],[2,0]], [[0,1],[1,1],[2,1]], [[0,2],[1,2],[2,2]],
        [[0,0],[1,1],[2,2]], [[0,2],[1,1],[2,0]]
      ];
      for (const line of lines) {
        const owners = line.map(([r, c]) => {
          const stack = boardState[r][c];
          if (stack.length === 0) return null;
          return piecesState[stack[stack.length - 1]].owner;
        });
        if (owners[0] !== null && owners[0] === owners[1] && owners[1] === owners[2]) {
          return owners[0];
        }
      }
      return null;
    }

    // 初心者AI：ランダム
    function aiBeginnerMove() {
      const moves = getAllLegalMoves(2, gameState.board, gameState.pieces);
      if (moves.length === 0) return null;
      return moves[Math.floor(Math.random() * moves.length)];
    }

    // 中級AI：勝てるなら勝つ、負けそうなら防ぐ
    function aiIntermediateMove() {
      const board = copyBoard();
      const pieces = copyPieces();
      const aiMoves = getAllLegalMoves(2, board, pieces);

      // AIが勝てる手を探す
      for (const move of aiMoves) {
        const undoInfo = applyMoveToState(move, board, pieces);
        const winner = checkWinFromState(board, pieces);
        undoMoveFromState(undoInfo, board, pieces);
        if (winner === 2) return move;
      }

      // P1の勝ちを防ぐ
      // P1の手をシミュレートして、P1が勝てる位置を見つける
      const p1Moves = getAllLegalMoves(1, board, pieces);
      for (const p1Move of p1Moves) {
        const undoInfo = applyMoveToState(p1Move, board, pieces);
        const winner = checkWinFromState(board, pieces);
        undoMoveFromState(undoInfo, board, pieces);
        if (winner === 1) {
          // この位置をAIがブロックできるか
          for (const aiMove of aiMoves) {
            if (aiMove.toRow === p1Move.toRow && aiMove.toCol === p1Move.toCol) {
              return aiMove;
            }
          }
        }
      }

      // 中央を優先
      const centerMove = aiMoves.find(m => m.toRow === 1 && m.toCol === 1);
      if (centerMove) return centerMove;

      // ランダム
      return aiBeginnerMove();
    }

    // 上級AI：ミニマックス
    function aiAdvancedMove() {
      const board = copyBoard();
      const pieces = copyPieces();
      const moves = getAllLegalMoves(2, board, pieces);
      if (moves.length === 0) return null;

      let bestMove = null;
      let bestScore = -Infinity;

      for (const move of moves) {
        const undoInfo = applyMoveToState(move, board, pieces);
        const score = minimax(board, pieces, 2, false, -Infinity, Infinity);
        undoMoveFromState(undoInfo, board, pieces);
        if (score > bestScore) {
          bestScore = score;
          bestMove = move;
        }
      }
      return bestMove || aiIntermediateMove();
    }

    // プロAI：深いミニマックス
    function aiProMove() {
      const board = copyBoard();
      const pieces = copyPieces();
      const moves = getAllLegalMoves(2, board, pieces);
      if (moves.length === 0) return null;

      let bestMove = null;
      let bestScore = -Infinity;

      for (const move of moves) {
        const undoInfo = applyMoveToState(move, board, pieces);
        const score = minimax(board, pieces, 4, false, -Infinity, Infinity);
        undoMoveFromState(undoInfo, board, pieces);
        if (score > bestScore) {
          bestScore = score;
          bestMove = move;
        }
      }
      return bestMove || aiAdvancedMove();
    }

    function minimax(boardState, piecesState, depth, isMaximizing, alpha, beta) {
      const winner = checkWinFromState(boardState, piecesState);
      if (winner === 2) return 10000 + depth;
      if (winner === 1) return -10000 - depth;
      if (depth === 0) return evaluateBoard(boardState, piecesState);

      const player = isMaximizing ? 2 : 1;
      const moves = getAllLegalMoves(player, boardState, piecesState);
      if (moves.length === 0) return evaluateBoard(boardState, piecesState);

      if (isMaximizing) {
        let maxScore = -Infinity;
        for (const move of moves) {
          const undoInfo = applyMoveToState(move, boardState, piecesState);
          const score = minimax(boardState, piecesState, depth - 1, false, alpha, beta);
          undoMoveFromState(undoInfo, boardState, piecesState);
          maxScore = Math.max(maxScore, score);
          alpha = Math.max(alpha, score);
          if (beta <= alpha) break;
        }
        return maxScore;
      } else {
        let minScore = Infinity;
        for (const move of moves) {
          const undoInfo = applyMoveToState(move, boardState, piecesState);
          const score = minimax(boardState, piecesState, depth - 1, true, alpha, beta);
          undoMoveFromState(undoInfo, boardState, piecesState);
          minScore = Math.min(minScore, score);
          beta = Math.min(beta, score);
          if (beta <= alpha) break;
        }
        return minScore;
      }
    }

    function evaluateBoard(boardState, piecesState) {
      let score = 0;
      const lines = [
        [[0,0],[0,1],[0,2]], [[1,0],[1,1],[1,2]], [[2,0],[2,1],[2,2]],
        [[0,0],[1,0],[2,0]], [[0,1],[1,1],[2,1]], [[0,2],[1,2],[2,2]],
        [[0,0],[1,1],[2,2]], [[0,2],[1,1],[2,0]]
      ];

      for (const line of lines) {
        let aiCount = 0, p1Count = 0, empty = 0;
        for (const [r, c] of line) {
          const stack = boardState[r][c];
          if (stack.length === 0) { empty++; }
          else {
            const owner = piecesState[stack[stack.length - 1]].owner;
            if (owner === 2) aiCount++;
            else p1Count++;
          }
        }
        if (aiCount === 3) return 10000;
        if (p1Count === 3) return -10000;
        if (aiCount === 2 && empty === 1) score += 100;
        if (p1Count === 2 && empty === 1) score -= 150;
        if (aiCount === 1 && empty === 2) score += 10;
        if (p1Count === 1 && empty === 2) score -= 10;
      }

      // 中央ボーナス
      const center = boardState[1][1];
      if (center.length > 0) {
        const centerOwner = piecesState[center[center.length - 1]].owner;
        score += centerOwner === 2 ? 50 : -50;
      }

      return score;
    }

    // 実際にゲーム状態に手を適用
    function executeMove(pieceId, toRow, toCol) {
      const piece = gameState.pieces[pieceId];
      const isFromBoard = piece.row !== null;
      const fromRow = piece.row;
      const fromCol = piece.col;

      const destStack = gameState.board[toRow][toCol];
      const isGobble = destStack.length > 0;

      // 移動元から削除
      if (isFromBoard) {
        const fromStack = gameState.board[fromRow][fromCol];
        const idx = fromStack.indexOf(piece.id);
        if (idx !== -1) fromStack.splice(idx, 1);
      }

      // 移動先に追加
      destStack.push(piece.id);
      piece.row = toRow;
      piece.col = toCol;

      // 3D表示
      if (isFromBoard) {
        movePiece3D(piece.id, fromRow, fromCol, toRow, toCol);
      } else {
        placePiece3D(piece.id, toRow, toCol, true);
      }

      // 効果音
      if (isGobble) { playSound('gobble'); }
      else if (isFromBoard) { playSound('move'); }
      else { playSound('place'); }

      updatePieceVisibility();
      renderReserves();

      // 勝敗判定
      const result = checkWin();
      if (result) {
        gameState.winner = result.winner;
        gameState.winningLine = result.line;
        gameState.gameOver = true;
        highlightWinningLine3D(result.line, result.winner);
        playSound('win');
        setTimeout(() => showVictory(result.winner), 800);
      } else {
        gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
        setStatusMessage('');
        playSound('turn');

        if (gameState.gameMode === 'CPU' && gameState.currentPlayer === 2) {
          setTimeout(() => aiMove(), 600);
        }
      }
      updateStatusBar();
    }

    // ====================================
    // イベント登録
    // ====================================
    document.getElementById('btn-new-game').addEventListener('click', showModeSelection);
    document.getElementById('victory-new-game').addEventListener('click', showModeSelection);

    // ====================================
    // 初期化
    // ====================================
    init3D();
    showModeSelection();
  </script>
</body>
</html>
